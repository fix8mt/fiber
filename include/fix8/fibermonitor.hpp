//-----------------------------------------------------------------------------------------
// fiber (header only)
// Copyright (C) 2022-23 Fix8 Market Technologies Pty Ltd
//   by David L. Dight
// see https://github.com/fix8mt/fiber
//
// Lightweight header-only stackful per-thread fiber
//		with built-in roundrobin scheduler x86_64 / linux only
//
// Distributed under the Boost Software License, Version 1.0 August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//----------------------------------------------------------------------------------------
#ifndef FIX8_FIBERMONITOR_HPP_
#define FIX8_FIBERMONITOR_HPP_

//----------------------------------------------------------------------------------------
#include <cctype>
#include <termbox.h>
#include <sys/ioctl.h>
#include <unistd.h>

//-----------------------------------------------------------------------------------------
#if defined FIBER_NO_INSTRUMENTATION || !defined FIX8_FIBER_INSTRUMENTATION_
#error "fiber_monitor can't be built with FIBER_NO_INSTRUMENTATION defined"
#endif

//-----------------------------------------------------------------------------------------
namespace FIX8 {

//-----------------------------------------------------------------------------------------
using xy_coord = std::pair<int, int>; // x,y
using window_coord = std::pair<xy_coord, xy_coord>;

struct window_frame : window_coord
{
	using window_coord::window_coord;
	constexpr window_frame(xy_coord dim) : window_coord({{},{dim.first, dim.second}}) {}
	xy_coord& upper() { return first; }
	xy_coord& lower() { return second; }
	constexpr xy_coord upper() const { return first; }
	constexpr xy_coord lower() const { return second; }
	constexpr bool empty() const { return *this == window_coord(); }
};

class fiber_monitor
{
public:
	enum class sort_mode { by_sched, by_id, by_ms, by_tms, by_name, by_flag, by_ctxsw, by_depth, by_launchorder, count };
	using enum sort_mode;

	static xy_coord get_terminal_dimensions()
	{
		struct winsize w;
		return ioctl(STDOUT_FILENO, TIOCGWINSZ, &w) == 0 ? xy_coord{ w.ws_col, w.ws_row } : xy_coord{};
	}

private:
	sort_mode _mode;
	const std::chrono::milliseconds _timeout;
	std::chrono::steady_clock::time_point _tp;
	bool _quit{}, _pause{};
	xy_coord _dimensions;
#if defined FIX8_FIBER_MULTITHREADING_
	f8_spin_lock _pre_spl;
#endif
	static constexpr const std::array<const char *, static_cast<int>(count)>
		_snames { "sched", "id", "time", "delta time", "name", "flags", "ctxswtch", "depth", "launch order"  };

public:
	fiber_monitor(std::chrono::milliseconds timeout=std::chrono::milliseconds(1), sort_mode mode=by_id)
		: _mode(mode), _timeout(timeout), _tp{std::chrono::steady_clock::now()}
	{
		tb_init();
		_dimensions = { tb_width(), tb_height() };
	}
	fiber_monitor(const fiber_monitor&) = delete;
	fiber_monitor& operator=(const fiber_monitor&) = delete;

	~fiber_monitor()
	{
		tb_shutdown();
	}

	bool is_quit() const noexcept { return _quit; }
	bool operator! () const noexcept { return is_quit(); }
	std::pair<int, int> get_dimensions() const noexcept { return _dimensions; }

	static std::string sort_help() noexcept
	{
		std::ostringstream result;
		for (int ii{}; const auto pp : _snames)
			result << ++ii << ':' << pp << ' ';
		return std::move(result.str());
	}

	void update_row(int row, int pos, bool iscurrent, const fiber_base& what) const
	{
		tb_printf(0, row, 0, iscurrent ? TB_BOLD|TB_RED : 0,
			"%-4u %c %-4s %-4s %-4s %6u %6u %4u %#14lx %#14lx %8u %8u %7s %3u %15s",
			pos, iscurrent ? '*' : ' ', what.get_id().to_string().c_str(), what.get_pid().to_string().c_str(),
			what.get_prev_id().to_string().c_str(), what._ctxswtchs,
			std::chrono::duration_cast<std::chrono::milliseconds>(what._extime).count(),
			std::chrono::duration_cast<std::chrono::milliseconds>(what._exdelta).count(),
			what._stk, what._stk_alloc, what._stk_alloc ? (reinterpret_cast<unsigned long>(what._stk_alloc + what._stacksz
			 / sizeof(uintptr_t) - 1) - reinterpret_cast<unsigned long>(what._stk)) : 0, what._stacksz,
			what.get_flags_as_string().c_str(), what._params.launch_order, what._params.name);
	}

	void update(window_frame winpos=window_frame(), const fiber::cvars *vs=nullptr)
	{
		if (static thread_local bool notfirst{}; std::exchange(notfirst, true))
		{
			if (auto tp { std::chrono::steady_clock::now() }; (tp - _tp) < _timeout)
				return;
			else
				_tp = tp;
		}

		static constexpr const char *banner {
			"#      fid  pfid prev  ctxsw  t(ms)   ^t      stack ptr    stack alloc    depth  stacksz     flags ord            name"};

		if (!_pause)
		{
			if (!vs)
				vs = &fibers::const_get_vars();
			if (winpos.empty())
				winpos = window_frame(_dimensions);
			int y{winpos.upper().second}, pos{};
			tb_printf(0, y++, TB_BOLD|TB_WHITE, TB_GREEN, banner);
			if (_mode == by_sched)
			{
				update_row(y++, pos++, true, *vs->_curr);
				for (const auto& pp : vs->_sched) // scheduled
					update_row(y++, pos++, false, *pp);
				if (vs->_gflags[static_cast<int>(global_fiber_flags::showdetached)])
				{
					pos = 0;
					for (const auto& pp : vs->_det) // detached (shown with -ve #)
						update_row(y++, --pos, false, *pp);
				}
			}
			else if (_mode == by_id)
				for (const auto& pp : vs->_uniq) // all fibers
					update_row(y++, pos++, pp == vs->_curr, *pp);
			else
			{
				struct tcmp
				{
					sort_mode _smode;
					tcmp(sort_mode smode) : _smode(smode) {}
					bool operator()(const fiber_base_ptr& lhs, const fiber_base_ptr& rhs) const
					{
						switch(_smode)
						{
						case by_ms:
							return lhs->_extime < rhs->_extime;
						case by_tms:
							return lhs->_exdelta < rhs->_exdelta;
						case by_name:
							return std::strcmp(lhs->_params.name, rhs->_params.name) < 0;
						case by_flag:
							return lhs->_flags.to_ulong() < rhs->_flags.to_ulong();
						case by_ctxsw:
							return lhs->_ctxswtchs < rhs->_ctxswtchs;
						case by_launchorder:
							return lhs->_params.launch_order < rhs->_params.launch_order;
						case by_depth:
							return lhs->_stk_alloc ?
								(reinterpret_cast<unsigned long>(lhs->_stk_alloc + lhs->_stacksz
								 / sizeof(uintptr_t) - 1) - reinterpret_cast<unsigned long>(lhs->_stk)) <
								(reinterpret_cast<unsigned long>(rhs->_stk_alloc + rhs->_stacksz
								 / sizeof(uintptr_t) - 1) - reinterpret_cast<unsigned long>(rhs->_stk)) : true;
						default:
							break;
						}
						return false;
					}
				};
				std::multiset<fiber_base_ptr, tcmp> tset(_mode);
				for (const auto pp : vs->_uniq) // all fibers
					tset.emplace(pp);
				for (const auto& pp : tset)
					update_row(y++, pos++, pp == vs->_curr, *pp);
			}
			// clear remaining window
			for (int jj{y}; jj < winpos.lower().second; ++jj)
				for (int kk{}; kk < winpos.lower().first; ++kk)
					tb_set_cell(kk, jj, ' ', TB_DEFAULT, TB_DEFAULT);
		}

		if (tb_event event; tb_peek_event(&event, 0) != TB_ERR_NO_EVENT && event.type == TB_EVENT_KEY)
		{
			switch (event.ch)
			{
			case TB_KEY_SPACE:
				_mode = static_cast<sort_mode>((static_cast<int>(_mode) + 1) % static_cast<int>(count));
				break;
			case 'p':
				_pause ^= true;
				break;
			case 'x':
				_quit = true;
				break;
			case '0':
				break;
			default:
				if (std::isdigit(event.ch)) //1 - 9
					_mode = sort_mode(static_cast<int>(event.ch) - 0x31);
				break;
			}
		}
		const auto smi { static_cast<int>(_mode) };
		tb_printf(0, tb_height() - 1, 0, TB_GREEN, "<space>,<1-9> sort mode(%d:%s), <p> pause, <x> exit", smi + 1, _snames[smi]);
#if defined FIX8_FIBER_MULTITHREADING_
		f8_scoped_spin_lock guard(_pre_spl);
#endif
		tb_present();
	}
};

//-----------------------------------------------------------------------------------------
} // namespace FIX8

#endif // FIX8_FIBERMONITOR_HPP_
