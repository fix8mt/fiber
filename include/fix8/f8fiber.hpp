//-----------------------------------------------------------------------------------------
// fiber (header only)
// Copyright (C) 2022 Fix8 Market Technologies Pty Ltd
//   by David L. Dight
// see https://github.com/fix8mt/f8fiber
//
// Lightweight header-only stackful per-thread fiber
//		with built-in roundrobin scheduler x86_64 / linux only
//
// Distributed under the Boost Software License, Version 1.0 August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//----------------------------------------------------------------------------------------
#ifndef FIX8_FIBER_HPP_
#define FIX8_FIBER_HPP_

//----------------------------------------------------------------------------------------
#include <iostream>
#include <iomanip>
#include <type_traits>
#include <future>
#include <deque>
#include <chrono>
#include <algorithm>
#include <cstring>
#include <functional>
#include <stdexcept>
#include <bitset>
#include <mutex>
#include <condition_variable>
#include <set>
#include <pthread.h>

//-----------------------------------------------------------------------------------------
#if !defined SIGSTKSZ
# define SIGSTKSZ 131072 // 128kb recommended
#endif
#if !defined FIBERNAMELEN
# define FIBERNAMELEN 16 // including null terminator
#endif

//-----------------------------------------------------------------------------------------
namespace FIX8 {

//-----------------------------------------------------------------------------------------
#if !defined f8_nonconstructible
/// simple non-constructable base
class f8_nonconstructible
{
protected:
	f8_nonconstructible() = delete;
	~f8_nonconstructible() = delete;
};
#endif

//-----------------------------------------------------------------------------------------
/// unique fiber id
class fiber_id
{
	const void *_ptr{ nullptr };

public:
	fiber_id() = default;
	explicit fiber_id(const void *ptr) noexcept : _ptr{ ptr } {}

#if __cplusplus >= 202002L
	constexpr auto operator<=>(const fiber_id& other) const noexcept { return _ptr <=> other._ptr; }
#else
	constexpr bool operator==(const fiber_id& other) const noexcept { return _ptr == other._ptr; }
	constexpr bool operator!=(const fiber_id& other) const noexcept { return _ptr != other._ptr; }
	constexpr bool operator<(const fiber_id& other) const noexcept { return _ptr < other._ptr; }
	constexpr bool operator>(const fiber_id& other) const noexcept { return other._ptr < _ptr; }
	constexpr bool operator<=(const fiber_id& other) const noexcept { return !(*this > other); }
	constexpr bool operator>=(const fiber_id& other) const noexcept { return !(*this < other); }
#endif

	template<typename charT, class traitsT>
	friend std::basic_ostream<charT, traitsT>& operator<<(std::basic_ostream<charT, traitsT>& os, const fiber_id& what)
	{
		if (what._ptr)
			return os << std::dec << reinterpret_cast<uint64_t>(what._ptr) % 10000;
		return os << "NaF";
	}

	constexpr explicit operator bool() const noexcept { return _ptr != nullptr; }
	constexpr bool operator!() const noexcept { return _ptr == nullptr; }

	friend class f8_this_fiber;
};

//-----------------------------------------------------------------------------------------
class f8_this_fiber : protected f8_nonconstructible
{
public:
	static fiber_id get_id() noexcept;
	static fiber_id get_prev_id() noexcept;
	static fiber_id get_pid() noexcept;
	static const char *name(const char *what=nullptr) noexcept;
	static void yield() noexcept;
	template<typename Clock, typename Duration>
	static void sleep_until(const std::chrono::time_point<Clock, Duration>& sltime);
	template<typename Rep, typename Period>
	static void sleep_for(const std::chrono::duration<Rep, Period>& retime);
};

class f8_fibers : protected f8_nonconstructible
{
public:
	static int size() noexcept;
	static int size_ready() noexcept;
	static bool has_fibers() noexcept;
	static bool has_ready_fibers() noexcept;
	static void sort() noexcept;
	static void print(std::ostream& os) noexcept;
};

//-----------------------------------------------------------------------------------------
class fiber_error : public std::system_error // from boost::fiber
{
public:
	explicit fiber_error(std::error_code ec) : std::system_error{ec} {}
	fiber_error(std::error_code ec, const char *what_arg) : std::system_error{ec, what_arg} {}
	fiber_error(std::error_code ec, const std::string& what_arg) : std::system_error{ec, what_arg} {}
};

template<typename T>
struct is_launch_policy : public std::false_type {}; // from boost::fiber

enum class launch { dispatch, post, none }; // from boost::fiber

template<>
struct is_launch_policy<launch> : public std::true_type {}; // from boost::fiber

template<typename T>
inline constexpr bool is_launch_policy_v = is_launch_policy<T>::value; // C++14 enhancement

//-----------------------------------------------------------------------------------------
enum fiber_flags { main, finished, suspended, dispatched, detached, notstarted, joinonexit, count }; // mfsednj

struct fiber_params
{
	int launch_order{99};
	const char name[FIBERNAMELEN]{};
	bool join{};
	// these next values can't be modified once the fiber has been created
	const size_t stacksz{SIGSTKSZ};
	const launch policy{launch::post};
	char *const stack{}; // optional user supplied stack
};

//-----------------------------------------------------------------------------------------
class alignas(16) fiber_base
{
	uintptr_t *_stk; // top of fiber stack
	const uintptr_t _stacksz;
	uintptr_t *const _stk_alloc{}; // allocated stack memory
	fiber_params _params;
	const fiber_id _pfid; // parent fiber
	fiber_id _prev_fiber;
	std::bitset<fiber_flags::count> _flags;
	std::chrono::steady_clock::time_point _tp{};
	std::condition_variable _cv_join;
	std::mutex _join_mutex;

	template<typename Wrapper>
	static void jumper(void *ptr) noexcept;

	// asm stack switch routine
	static void _coroswitch(fiber_base *old, fiber_base *newer) noexcept;

	static void destroy(fiber_base *pp)
	{
		pp->~fiber_base();
		if (!pp->_params.stack)
			delete[] reinterpret_cast<uintptr_t*>(pp);
	}
	static size_t get_default_stacksz()
	{
		static thread_local size_t sz([]()
		{
			size_t size{};
			if (pthread_attr_t attr; pthread_attr_init(&attr) == 0)
				pthread_attr_getstacksize(&attr, &size);
			return size;
		}());
		return sz;
	}

	template<typename Fn>
	struct callable_wrapper
	{
		typename std::decay_t<Fn> _func;
		callable_wrapper(Fn&& func) noexcept : _func(std::forward<Fn>(func)) {}
	};

	template<typename Fn>
	void setup_continuation(Fn&& func) noexcept
	{
		_stk = _stk_alloc + _stacksz / sizeof(uintptr_t) - 1; // set top of stack
		*--_stk = reinterpret_cast<uintptr_t>(jumper<callable_wrapper<Fn>>);
		*--_stk = reinterpret_cast<uintptr_t>(new (reinterpret_cast<char*>(_stk_alloc) + sizeof(fiber_base))
			callable_wrapper(std::forward<Fn>(func))); // store at bottom of stack
		std::fill(_stk -= 7, _stk, 0x0);
	}

public:
	fiber_base() noexcept
		: _stacksz{get_default_stacksz()}, _params{.name="main",.stacksz=_stacksz}, _flags{1 << fiber_flags::main} {}

	template<typename Fn>
	fiber_base(fiber_params&& params, Fn&& func, uintptr_t *sp, size_t stacksz, fiber_id parent) noexcept
		: _stacksz(stacksz), _stk_alloc(sp), _params(std::move(params)), _pfid(parent),
			_flags{(1 << fiber_flags::notstarted) | (_params.join ? (1 << fiber_flags::joinonexit) : 0ULL)}
	{
		setup_continuation(std::forward<Fn>(func));
	}

	~fiber_base() noexcept = default;

	fiber_id get_id() const noexcept { return fiber_id(!is_main() ? this : nullptr); }
	constexpr fiber_id get_prev_id() const noexcept { return _prev_fiber; }
	constexpr fiber_id get_pid() const noexcept { return _pfid; }

	const char *name(const char *what=nullptr)
	{
		if (what && !is_main()) // you can't name main
		{
			const size_t len { std::strlen(what) }, adjlen { len + 1 > FIBERNAMELEN ? FIBERNAMELEN - 1 : len };
			char *ptr { const_cast<char*>(&_params.name[0]) }; // override const
			std::memcpy(ptr, what, adjlen);
			*(ptr + adjlen) = 0;
		}
		return _params.name;
	}
	int order(int ord) noexcept { return _params.launch_order = ord; }

	constexpr bool joinable() const noexcept { return !_flags[fiber_flags::finished]; };
	constexpr bool is_main() const noexcept { return _flags[fiber_flags::main]; };
	constexpr bool is_detached() const noexcept { return _flags[fiber_flags::detached]; };
	constexpr bool is_suspended() const noexcept { return _flags[fiber_flags::suspended]; };
	constexpr bool is_joinonexit() const noexcept { return _flags[fiber_flags::joinonexit]; };

	friend std::ostream& operator<<(std::ostream& os, const fiber_base& what);
	friend class fiber;
	friend f8_this_fiber;
	friend f8_fibers;
};

using fiber_base_ptr = std::shared_ptr<fiber_base>;

//-----------------------------------------------------------------------------------------
// static void fiber_base::_coroswitch(fiber_base *old, fiber_base *newer) noexcept;
asm(R"(.text
.align 16
.type _ZN4FIX810fiber_base11_coroswitchEPS0_S1_,@function
_ZN4FIX810fiber_base11_coroswitchEPS0_S1_:
   xor %rax,%rax
	cmp %rdi,%rsi
	jne doswitch
	ret
doswitch:
	subq $0x40,%rsp
   stmxcsr (%rsp)
   fnstcw  4(%rsp)
	movq %r15,8(%rsp)
	movq %r14,8*2(%rsp)
	movq %r13,8*3(%rsp)
	movq %r12,8*4(%rsp)
	movq %rbx,8*5(%rsp)
	movq %rbp,8*6(%rsp)
	movq %rdi,8*7(%rsp)

	mov %rsp,(%rdi)
	mov (%rsi),%rsp

   ldmxcsr (%rsp)
   fldcw  4(%rsp)
   movq 8(%rsp),%r15
   movq 8*2(%rsp),%r14
   movq 8*3(%rsp),%r13
   movq 8*4(%rsp),%r12
   movq 8*5(%rsp),%rbx
   movq 8*6(%rsp),%rbp
   movq 8*7(%rsp),%rdi
	movq 8*8(%rsp),%r8
	addq $0x48,%rsp
   jmp *%r8
.size _ZN4FIX810fiber_base11_coroswitchEPS0_S1_,.-_ZN4FIX810fiber_base11_coroswitchEPS0_S1_
.section .note.GNU-stack,"",%progbits
)");

//-----------------------------------------------------------------------------------------
class alignas(16) fiber
{
	fiber_base_ptr _ctx;

#define GetVars() auto& [uni, det, sch, cur, trm] { fiber::get_vars() }
#define GetVar(x) fiber::get_vars().x

	struct cvars
	{
		std::set<fiber_base_ptr> _uniq, _det;
		std::deque<fiber_base_ptr> _sched;
		fiber_base_ptr _curr;
		bool _term;

		~cvars() noexcept;
	};
	static cvars& get_vars() noexcept
	{
		// per thread singleton
		static thread_local fiber_base_ptr _def_ctx { std::make_shared<fiber_base>() };
		static thread_local cvars _cvars{._uniq={_def_ctx},._curr=_def_ctx,._term=false};
		return _cvars;
	}

	static void fiber_exit()
	{
		std::cout << "fiber has exited. Terminating application.\n";
		std::terminate();
	}
	static void sort_queue(std::deque<fiber_base_ptr>& sch) noexcept
	{
		std::sort(sch.begin(), sch.end(), [](const fiber_base_ptr& p1, const fiber_base_ptr& p2)
		{
			return p1->_params.launch_order < p2->_params.launch_order;
		});
	}

	// default current (main) fiber
	fiber() noexcept : _ctx { std::make_shared<fiber_base>() } {}

public:
	template<typename Fn, typename... Args, std::enable_if_t<!std::is_bind_expression_v<Fn>,int> = 0>
	fiber(Fn&& func, Args&&... args)
		: fiber({}, std::bind(std::forward<Fn>(func), std::forward<Args>(args)...)) {}

	template<typename Fn, typename... Args, std::enable_if_t<!std::is_bind_expression_v<Fn>,int> = 0>
	fiber(fiber_params&& params, Fn&& func, Args&&... args)
		: fiber(std::move(params), std::bind(std::forward<Fn>(func), std::forward<Args>(args)...)) {}

	template<typename Fn>
	fiber(Fn&& func) : fiber({}, std::forward<Fn>(func)) {}

	template<typename Fn>
	fiber(fiber_params&& params, Fn&& func)
	{
		const uintptr_t sz { (params.stacksz + sizeof(fiber_base)) & ~static_cast<uintptr_t>(0xff) }, szadj { sz / sizeof(uintptr_t) };
		uintptr_t *sp { params.stack	? new (reinterpret_cast<uintptr_t *>(params.stack)) uintptr_t[szadj] : new uintptr_t[szadj] };
		GetVars();
		_ctx.reset(new (reinterpret_cast<char*>(sp))
			fiber_base(std::move(params), std::forward<Fn>(func), sp, sz, cur->get_id()), [](auto *pp) { fiber_base::destroy(pp); });
		uni.insert(_ctx);
		sch.push_back(_ctx);
		sort_queue(sch);
		if (_ctx->_params.policy == launch::dispatch)
		{
			_ctx->_flags.set(fiber_flags::dispatched);
			resume();
		}
	}

	fiber(const fiber&) = delete;
	fiber& operator=(const fiber&) = delete;

	~fiber()
	{
		if (joinable() && !is_detached())
		{
			if (is_joinonexit())
				join();
			else
				fiber_exit(); // well behaved fibers shouldn't get here
		}
	}

	fiber(fiber_base_ptr from) noexcept : _ctx(std::move(from)) {}
	fiber(fiber&& other) noexcept
	{
		_ctx.swap(other._ctx);
	}
	fiber& operator=(fiber&& other) noexcept
	{
		if (joinable())
			fiber_exit();
		if (_ctx != other._ctx)
			_ctx.swap(other._ctx);
		return *this;
	}

	fiber& set_joinonexit(bool set=true) noexcept
	{
		(_ctx->_params.join = set) ? _ctx->_flags.set(fiber_flags::joinonexit)
											: _ctx->_flags.reset(fiber_flags::joinonexit);
		return *this;
	}

	fiber& set_params(const char *nm=nullptr, int lo=99, bool jn=false) noexcept
	{
		name(nm);
		order(lo);
		set_joinonexit(jn);
		return *this;
	}

	void join()
	{
		if (auto& cur { GetVar(_curr) }; _ctx != cur)
		{
			if (!joinable())
				throw fiber_error { std::make_error_code(std::errc::invalid_argument),
					"fiber: fiber not joinable" };
			else
			{
				std::unique_lock jlock(_ctx->_join_mutex);
				_ctx->_cv_join.wait(jlock, [this]
				{
					f8_this_fiber::yield();
					return !joinable();
				});
			}
		}
		else
			throw fiber_error { std::make_error_code(std::errc::resource_deadlock_would_occur),
				"fiber: fiber cannot self-join" };
	}
	void join_if()
	{
		if (joinable())
			join();
	}

	void detach()
	{
		if (is_detached())
			throw fiber_error { std::make_error_code(std::errc::invalid_argument),
				"fibers: fiber already detached" };
		else if (!joinable())
			throw fiber_error { std::make_error_code(std::errc::invalid_argument),
				"fiber: fiber not joinable" };
		else
		{
			_ctx->_flags.set(fiber_flags::detached);
			GetVars();
			det.insert(_ctx);
			auto csched { sch };
			sch.clear();
			for (auto& pp : csched)
				if (pp != _ctx) // remove from scheduler
					sch.push_back(_ctx);
		}
	}

	void resume()
	{
		if (!joinable())
			throw fiber_error { std::make_error_code(std::errc::invalid_argument),
				"fibers: fiber not joinable" };
		else if (is_detached())
			throw fiber_error { std::make_error_code(std::errc::invalid_argument),
				"fibers: cannot resume detached fiber" };
		GetVars();
		if (cur == _ctx)
			throw fiber_error { std::make_error_code(std::errc::resource_deadlock_would_occur),
				"fibers: fiber cannot self-join" };
		else if (uni.count(_ctx))
		{
			if (auto& front { sch.front() }; front != _ctx)
			{
				for (auto itr { sch.begin() }; itr != sch.end(); ++itr)
				{
					if (*itr == _ctx)
					{
						itr->swap(front); // swap next with specified fiber
						break;
					}
				}
			}
			f8_this_fiber::yield();
		}
	}
	void resume_if()
	{
		if (joinable())
			resume();
	}
	void suspend()
	{
		if (!joinable())
			throw fiber_error { std::make_error_code(std::errc::invalid_argument),
				"fibers: fiber not joinable" };
		else if (is_detached())
			throw fiber_error { std::make_error_code(std::errc::invalid_argument),
				"fibers: cannot suspend detached fiber" };
		else if (is_suspended())
			throw fiber_error { std::make_error_code(std::errc::invalid_argument),
				"fibers: fiber already suspended" };
		_ctx->_tp = decltype(_ctx->_tp)();
		_ctx->_flags.set(fiber_flags::suspended);
	}
	void unsuspend()
	{
		if (!joinable())
			throw fiber_error { std::make_error_code(std::errc::invalid_argument),
				"fibers: fiber not joinable" };
		else if (is_detached())
			throw fiber_error { std::make_error_code(std::errc::invalid_argument),
				"fibers: cannot unsuspend detached fiber" };
		else if (!is_suspended())
			throw fiber_error { std::make_error_code(std::errc::invalid_argument),
				"fibers: fiber not suspended" };
		_ctx->_tp = decltype(_ctx->_tp)();
		_ctx->_flags.reset(fiber_flags::suspended);
	}
	void kill()
	{
		if (!joinable())
			throw fiber_error { std::make_error_code(std::errc::invalid_argument),
				"fibers: fiber not joinable" };
		else if (is_detached())
			throw fiber_error { std::make_error_code(std::errc::invalid_argument),
				"fibers: cannot kill detached fiber" };
		_ctx->_flags.set(fiber_flags::finished); // will not be scheduled again
	}

	template<typename Fn, typename... Args, std::enable_if_t<!std::is_bind_expression_v<Fn>,int> = 0>
	void resume_with(Fn&& func, Args&&... args)
		{ resume_with(std::bind(std::forward<Fn>(func), std::forward<Args>(args)...)); }

	template<typename Fn>
	void resume_with(Fn&& func)
	{
		_ctx->setup_continuation(std::forward<Fn>(func));
		resume();
	}

	void swap(fiber& other) noexcept
	{
		if (_ctx != other._ctx)
			_ctx.swap(other._ctx);
	}
	static void sort() noexcept
	{
		sort_queue(GetVar(_sched));
	}

	bool joinable() const noexcept { return _ctx->joinable(); }
	bool is_main() const noexcept { return _ctx->is_main(); }
	bool is_detached() const noexcept { return _ctx->is_detached(); }
	bool is_suspended() const noexcept { return _ctx->is_suspended(); };
	bool is_joinonexit() const noexcept { return _ctx->is_joinonexit(); }
	explicit operator bool() const noexcept { return joinable(); }
	bool operator! () const noexcept { return !joinable(); }

	const char *name(const char *what=nullptr) noexcept { return _ctx->name(what); }
	int order(int ord=99) noexcept { return ord == 99 ? _ctx->_params.launch_order : _ctx->_params.launch_order = ord; }
	fiber_id get_id() const noexcept { return _ctx->get_id(); }
	fiber_id get_prev_id() const noexcept { return _ctx->get_prev_id(); }
	fiber_id get_pid() const noexcept { return _ctx->get_pid(); }

	friend std::ostream& operator<<(std::ostream& os, const fiber_base& what);
	friend std::ostream& operator<<(std::ostream& os, const fiber& what) { return os << *what._ctx; }
	friend f8_this_fiber;
	friend f8_fibers;
	friend fiber_base;
};

inline void swap(fiber& first, fiber& second) noexcept
{
	first.swap(second);
}

inline bool operator<(const fiber& left, const fiber& right) noexcept
{
	return left.get_id() < right.get_id();
}

//-----------------------------------------------------------------------------------------
template<typename Wrapper>
void fiber_base::jumper(void *ptr) noexcept
{
	static_cast<Wrapper*>(ptr)->_func();
	GetVars();
	cur->_flags.set(fiber_flags::finished);
	if (!sch.empty())
		f8_this_fiber::yield();
	if (!det.empty()) // pickup temporarily detached main
	{
		auto dt { det.begin() };
		det.erase(dt);
		fiber_base::_coroswitch(cur.get(), dt->get());
	}
	fiber::fiber_exit(); // well behaved fibers shouldn't get here
}

//-----------------------------------------------------------------------------------------
// Activate per thread pending/suspended fibers at thread exit
fiber::cvars::~cvars() noexcept
{
	if (!_det.empty())
	{
		for (auto& pp : _det) // place detached back on scheduler
			_sched.emplace_back(pp);
		_det.clear();
		sort_queue(_sched);
	}
	_term = true;
	if (!_sched.empty())
	{
		for (auto& pp : _sched)
			if (pp->is_suspended()) // unsuspend any suspended fiber
				pp->_flags.reset(fiber_flags::suspended);
		f8_this_fiber::yield();
	}
}

//-----------------------------------------------------------------------------------------
// custom async, uses fiber, modified boost::fiber::async
// uses std::invoke_result (std::result_of is deprecated)
template<typename Fn, typename... Args>
std::future<typename std::invoke_result_t<typename std::decay_t<Fn>,typename std::decay_t<Args>...>>
async(Fn&& fn, Args... args)
{
	using result_type = typename std::invoke_result_t<typename std::decay_t<Fn>,typename std::decay_t<Args>...>;
	std::packaged_task<result_type(typename std::decay_t<Args>...)> task { std::forward<Fn>(fn) };
	std::future<result_type> fut { task.get_future() };
	fiber(std::move(task), std::forward<Args>(args)...).detach();
	return fut;
}

template<typename Fn, typename... Args>
std::future<typename std::invoke_result_t<typename std::decay_t<Fn>,typename std::decay_t<Args>...>>
async(fiber_params&& params, Fn&& fn, Args... args)
{
	using result_type = typename std::invoke_result_t<typename std::decay_t<Fn>,typename std::decay_t<Args>...>;
	std::packaged_task<result_type(typename std::decay_t<Args>...)> task { std::forward<Fn>(fn) };
	std::future<result_type> fut { task.get_future() };
	fiber(std::move(params), std::move(task), std::forward<Args>(args)...).detach();
	return fut;
}

//-----------------------------------------------------------------------------------------
std::ostream& operator<<(std::ostream& os, const fiber_base& what)
{
	os << (&what == GetVar(_curr).get() ? '*' : ' ')
		<< ' ' << std::left << std::setw(4) << what.get_id()
		<< ' ' << std::left << std::setw(4) << what.get_pid()
		<< ' ' << std::left << std::setw(4) << what.get_prev_id()
		<< ' ' << std::right << std::setw(14) << what._stk
		<< ' ' << std::right << std::setw(14) << what._stk_alloc
		<< ' ' << std::right << std::setw(7) <<
			(what._stk_alloc ? (reinterpret_cast<unsigned long>(what._stk_alloc + what._stacksz
									 / sizeof(uintptr_t) - 1) - reinterpret_cast<unsigned long>(what._stk)) : 0)
		<< ' ' << std::right << std::setw(8) << what._stacksz
		<< ' ';
	static constexpr const char *str{"mfspdnj"};
	for (int ii{}; ii < what._flags.size(); ++ii)
		os << (what._flags.test(ii) ? str[ii] : '_');
	return os << std::setw(4) << std::dec << what._params.launch_order
		<< ' ' << what._params.name; //  << " (" << reinterpret_cast<const void*>(what.name) << ')';
}

//-----------------------------------------------------------------------------------------
fiber_id f8_this_fiber::get_id() noexcept { return GetVar(_curr)->get_id(); }
fiber_id f8_this_fiber::get_prev_id() noexcept { return GetVar(_curr)->get_prev_id(); }
fiber_id f8_this_fiber::get_pid() noexcept { return GetVar(_curr)->get_pid(); }

void f8_this_fiber::yield() noexcept
{
	GetVars();
	while (!sch.empty())
	{
		auto& front { sch.front() };
		sch.pop_front();
		if (front->joinable() && uni.count(front))
		{
			if (front->is_suspended())
			{
				if (auto tse { front->_tp.time_since_epoch() };
					front->_tp.time_since_epoch() != decltype(tse)::zero() && front->_tp < std::chrono::steady_clock::now())
				{
					front->_flags.reset(fiber_flags::suspended);
					front->_tp = decltype(front->_tp)();
				}
				else
				{
					sch.push_back(front);
					continue;
				}
			}
			else if (trm && front->is_main())
			{
				det.emplace(front); // temporarily detach main
				continue;
			}
			front.swap(cur);
			if (cur->_flags[fiber_flags::notstarted])
				cur->_flags.reset(fiber_flags::notstarted);
			cur->_prev_fiber = front->get_id();
			sch.push_back(front);
			fiber_base::_coroswitch(front.get(), cur.get());
			break;
		}
		else
			uni.erase(front);
	}
}
template<typename Clock, typename Duration>
void f8_this_fiber::sleep_until(const std::chrono::time_point<Clock, Duration>& sltime)
{
	sleep_for(sltime - Clock::now());
}
template<typename Rep, typename Period>
void f8_this_fiber::sleep_for(const std::chrono::duration<Rep, Period>& retime)
{
	if (auto when { std::chrono::steady_clock::now() + retime }; when > std::chrono::steady_clock::now())
	{
		auto& cur { GetVar(_curr) };
		cur->_tp = when;
		cur->_flags.set(fiber_flags::suspended);
		yield();
	}
}
const char *f8_this_fiber::name(const char *what) noexcept { return GetVar(_curr)->name(what); }

//-----------------------------------------------------------------------------------------
int f8_fibers::size() noexcept { return GetVar(_sched).size(); }
int f8_fibers::size_ready() noexcept
{
	GetVars();
	return std::count_if(uni.cbegin(), uni.cend(), [&cur](auto& pp)
	{
		return pp != cur && !pp->is_suspended() && pp->joinable() && !pp->is_detached();
	});
}
bool f8_fibers::has_fibers() noexcept { return size(); }
bool f8_fibers::has_ready_fibers() noexcept { return size_ready(); }
void f8_fibers::print(std::ostream& os) noexcept
{
	os << "#      fid  pfid prev      stack ptr    stack alloc   depth  stacksz   flags ord name\n";
	int pos{};
	GetVars();
	os << std::left << std::setw(5) << std::dec << pos++ << *cur << std::endl;
	for (const auto& pp : sch) // scheduled
		os << std::left << std::setw(5) << std::dec << pos++ << *pp << std::endl;
	pos = 0;
	for (const auto& pp : det) // detached (shown with -ve #)
		os << std::left << std::setw(5) << std::dec << --pos << *pp << std::endl;
}
void f8_fibers::sort() noexcept { fiber::sort(); };

//-----------------------------------------------------------------------------------------
constexpr inline void launch_all_no_params() {}
template<typename Fn, typename... Fns>
constexpr void launch_all_no_params(Fn&& func, Fns&&... funcs)
{
	fiber(std::forward<Fn>(func)).detach();
	launch_all_no_params(std::forward<Fns>(funcs)...);
}
template<typename... Fns>
constexpr void launch_all(Fns&& ...funcs) { launch_all_no_params(std::forward<Fns>(funcs)...); }

constexpr inline void launch_all_params() {}
template<typename Ps, typename Fn, typename... Fns>
constexpr void launch_all_params(Ps&& params, Fn&& func, Fns&&... funcs)
{
	fiber(std::forward<Ps>(params), std::forward<Fn>(func)).detach();
	launch_all_params(std::forward<Fns>(funcs)...);
}
template<typename... Fns>
constexpr void launch_all_with_params(Fns&& ...funcs) { launch_all_params(std::forward<Fns>(funcs)...); }

//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
namespace this_fiber
{
	inline fiber_id get_id() noexcept { return f8_this_fiber::get_id(); }
	inline fiber_id get_prev_id() noexcept { return f8_this_fiber::get_prev_id(); }
	inline fiber_id get_pid() noexcept { return f8_this_fiber::get_pid(); }
	inline void yield() noexcept { return f8_this_fiber::yield(); }
	inline const char *name(const char *what=nullptr) noexcept { return f8_this_fiber::name(what); }

	template<typename Clock, typename Duration>
	inline void sleep_until(const std::chrono::time_point<Clock, Duration>& sltime)
		{ return f8_this_fiber::sleep_until(sltime); }

	template<typename Rep, typename Period>
	inline void sleep_for(const std::chrono::duration<Rep, Period>& retime)
		{ return f8_this_fiber::sleep_for(retime); }
}

namespace fibers
{
	inline int size() noexcept { return f8_fibers::size(); }
	inline int size_ready() noexcept { return f8_fibers::size_ready(); }
	inline bool has_fibers() noexcept { return fibers::size(); }
	inline bool has_ready_fibers() noexcept { return fibers::size_ready(); }
	inline void print(std::ostream& os=std::cout) noexcept { f8_fibers::print(os); }
	inline void sort() noexcept { f8_fibers::sort(); };
};

} // namespace FIX8

#endif // FIX8_FIBER_HPP_
