//-----------------------------------------------------------------------------------------
// f8_fiber (header only) based on boost::fiber, x86_64 / linux only / de-boosted
// Modifications Copyright (C) 2022 Fix8 Market Technologies Pty Ltd
// see https://github.com/fix8mt/f8fiber
//
// fcontext_t, jump_fcontext, make_fcontext, ontop_fcontext
//	boost::fiber, basic_protected_fixedsize_stack
//          Copyright Oliver Kowalke 2013.
//
// Distributed under the Boost Software License, Version 1.0 August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------------------
#ifndef FIX8_FIBER_HPP_
#define FIX8_FIBER_HPP_

#include <fcntl.h>
#include <sys/resource.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

#include <cstddef>
#include <tuple>
#include <new>
#include <utility>
#include <functional>
#include <iostream>

//-----------------------------------------------------------------------------------------
#if !defined (SIGSTKSZ)
# define SIGSTKSZ 131072 // 128kb recommended
#endif

//----------------------------------------------------------------------------------------
namespace FIX8 {

//-----------------------------------------------------------------------------------------
using fcontext_t = void *;
struct fcontext_transfer_t
{
	fcontext_t ctx;
	void *data;
};

struct fcontext_stack_t
{
	void *sptr;
	size_t ssize;
};

struct forced_unwind
{
	fcontext_t _fctx{};
	forced_unwind(fcontext_t fctx) : _fctx(fctx) {}
};

//-----------------------------------------------------------------------------------------
/// ABC stack
class f8_stack
{
protected:
	std::size_t _size;

public:
	f8_stack(std::size_t size=SIGSTKSZ) noexcept : _size(size) {}
	virtual fcontext_stack_t allocate() = 0;
	virtual void deallocate(fcontext_stack_t& sctx) { sctx = {}; }
};

//-----------------------------------------------------------------------------------------
/// Anonymous memory mapped region based stack
class f8_protected_fixedsize_stack final : public f8_stack
{
public:
	using f8_stack::f8_stack;
	fcontext_stack_t allocate() override
	{
		static const auto PageSize { static_cast<size_t>(sysconf(_SC_PAGESIZE)) };
		// calculate how many pages are required
		const std::size_t pages { (_size + PageSize - 1) / PageSize };
		// add one page at bottom that will be used as guard-page
		const std::size_t __size { (pages + 1) * PageSize };

		if (void *vp { ::mmap(0, __size, PROT_READ | PROT_WRITE, MAP_PRIVATE |
#if defined(USE_MAP_STACK)
			MAP_ANON | MAP_STACK,
#elif defined(MAP_ANON)
			MAP_ANON,
#else
			MAP_ANONYMOUS,
#endif
			-1, 0) }; vp == MAP_FAILED)
				throw std::bad_alloc();
		else
		{
			// conforming to POSIX.1-2001
			::mprotect(vp, PageSize, PROT_NONE);
			return { static_cast<char *>(vp) + __size, __size };
		}
	}

	void deallocate(fcontext_stack_t& sctx) noexcept override
	{
		if (sctx.sptr)
		{
			// conform to POSIX.4 (POSIX.1b-1993, _POSIX_C_SOURCE=199309L)
			::munmap(static_cast<char *>(sctx.sptr) - sctx.ssize, sctx.ssize);
		}
		f8_stack::deallocate(sctx);
	}
};

//-----------------------------------------------------------------------------------------
/// Simple heap based stack
class f8_fixedsize_heap_stack final : public f8_stack
{
public:
	using f8_stack::f8_stack;
	fcontext_stack_t allocate() override { return { static_cast<char *>(::operator new(_size)) + _size, _size }; }
	void deallocate(fcontext_stack_t& sctx) noexcept override
	{
		delete (static_cast<char *>(sctx.sptr) - sctx.ssize);
		f8_stack::deallocate(sctx);
	}
};

//-----------------------------------------------------------------------------------------
/// Placement stack
class f8_fixedsize_placement_stack final : public f8_stack
{
	char *_ptr;
public:
	f8_fixedsize_placement_stack(char *top, std::size_t size=SIGSTKSZ) noexcept : f8_stack(size), _ptr(top) {}
	fcontext_stack_t allocate() noexcept override { return { _ptr + _size, _size }; }
};

//-----------------------------------------------------------------------------------------
class f8_fiber
{
	fcontext_t _fctx { nullptr };
	void (*_dealloc)(void *) { nullptr };
	void *_rec { nullptr };

	f8_fiber(fcontext_t fctx) noexcept : _fctx { fctx } {}

	template<typename StackAlloc, typename Fn>
	class f8_fiber_record
	{
		fcontext_stack_t _stack;
		typename std::decay_t<StackAlloc> _salloc;
		typename std::decay_t<Fn> _fn;

		static void destroy(f8_fiber_record *ptr) noexcept
		{
			typename std::decay_t<StackAlloc> salloc { std::move(ptr->_salloc) };
			auto stack { ptr->_stack };
			ptr->~f8_fiber_record();
			salloc.deallocate(stack);
		}

	public:
		f8_fiber_record(fcontext_stack_t sctx, StackAlloc&& salloc, Fn&& fn) noexcept
			: _stack(sctx), _salloc(std::forward<StackAlloc>(salloc)), _fn(std::forward<Fn>(fn)) {}
		~f8_fiber_record() = default;

		void deallocate() noexcept { destroy(this); }

		fcontext_t run(fcontext_t fctx)
		{
			// invoke context-function
			f8_fiber fb { std::invoke(_fn, std::move(f8_fiber{fctx})) };
			return std::exchange(fb._fctx, nullptr);
		}
	};

public:
	f8_fiber() noexcept = default;

	/*! Ctor with arguments passed to std::bind; this allows you to simply pass
	  the bind arguments directly without needed to call bind yourself
	 \tparam Fn function type or method to invoke
    \tparam Args to pass to method (via bind)
	 \param fn function
    \param args to pass */
	template<typename Fn, typename... Args, std::enable_if_t<!std::is_bind_expression_v<Fn>,int> = 0>
	f8_fiber(Fn&& fn, Args&&... args) :
		f8_fiber { std::allocator_arg, f8_protected_fixedsize_stack(), std::bind(std::forward<Fn>(fn), std::forward<Args>(args)...) } {}

	/*! Ctor with custom allocator and arguments passed to std::bind; this allows you to simply pass
	  the bind arguments directly without needed to call bind yourself
	 \tparam StackAlloc allocator type
	 \tparam Fn function type or method to invoke
    \tparam Args to pass to method (via bind)
	 \param std::allocator_arg_t allocator disambiguator
	 \param salloc allocator object
	 \param fn function
    \param args to pass */
	template<typename StackAlloc, typename Fn, typename... Args, std::enable_if_t<!std::is_bind_expression_v<Fn>,int> = 0>
	f8_fiber(std::allocator_arg_t, StackAlloc&& salloc, Fn&& fn, Args&&... args) :
		f8_fiber { std::allocator_arg, std::forward<StackAlloc>(salloc), std::bind(std::forward<Fn>(fn), std::forward<Args>(args)...) } {}

	/*! Ctor with function argument (usually already bound with arguments)
	 \tparam Fn function type or method to invoke
	 \param fn function */
	template<typename Fn, std::enable_if_t<!std::is_base_of_v<f8_fiber, std::decay_t<Fn>>,int> = 0>
	f8_fiber(Fn&& fn) :
		f8_fiber { std::allocator_arg, f8_protected_fixedsize_stack(), std::forward<Fn>(fn) } {}

	/*! Ctor with allocator and function argument (usually already bound with arguments)
	 \tparam StackAlloc allocator type
	 \tparam Fn function type or method to invoke
	 \param std::allocator_arg_t allocator disambiguator
	 \param salloc allocator object
	 \param fn function */
	template<typename StackAlloc, typename Fn, typename Rec = f8_fiber_record<StackAlloc, Fn>>
	f8_fiber(std::allocator_arg_t, StackAlloc&& salloc, Fn&& fn)
		: _dealloc([](void *what) noexcept { static_cast<Rec *>(what)->deallocate(); })
	{
		auto sctx { salloc.allocate() };
		// reserve space for control structure
		void *storage { reinterpret_cast<void*>((reinterpret_cast<uintptr_t>(sctx.sptr) - static_cast<uintptr_t>(sizeof(Rec)))
			& ~static_cast<uintptr_t>(0xff)) };
		// placement new for control structure on context stack
		_rec = new (storage) Rec { sctx, std::forward<StackAlloc>(salloc), std::forward<Fn>(fn) };
		// 64byte gap between control structure and stack top, should be 16byte aligned
		void *top { reinterpret_cast<void *>(reinterpret_cast<uintptr_t>(storage) - static_cast<uintptr_t>(64)) };
		void *bottom { reinterpret_cast<void *>(reinterpret_cast<uintptr_t>(sctx.sptr) - static_cast<uintptr_t>(sctx.ssize)) };
		// create fast-context
		const std::size_t size { reinterpret_cast<uintptr_t>(top) - reinterpret_cast<uintptr_t>(bottom) };
		fcontext_t fctx { make_fcontext(top, size, [](fcontext_transfer_t t) noexcept // fiber_entry
		{
			// transfer control structure to the context-stack
			Rec *rec { static_cast<Rec *>(t.data) };
			try
			{
				t = jump_fcontext(t.ctx, nullptr); // jump back to 'create_context()'
				t.ctx = rec->run(t.ctx); // start executing
			}
			catch (const forced_unwind& e)
			{
				t = { e._fctx, nullptr };
			}
			// destroy context-stack of 'this' context on next context
			ontop_fcontext(t.ctx, rec, [](fcontext_transfer_t t) noexcept ->fcontext_transfer_t // fiber_exit
			{
				static_cast<Rec *>(t.data)->deallocate();
				return {};
			});
		}) };
		// transfer control structure to context-stack
		_fctx = jump_fcontext(fctx, _rec).ctx;
	}

	virtual ~f8_fiber()
	{
		if (_fctx)
		{
			if (_rec)
			{
				(_dealloc)(_rec);
				_rec = _fctx = nullptr;
			}
			else
			{
				ontop_fcontext(std::exchange(_fctx, nullptr), nullptr, [](fcontext_transfer_t t)->fcontext_transfer_t // fiber_unwind
				{
					throw forced_unwind(t.ctx);
					return {};
				});
			}
		}
	}

	f8_fiber(f8_fiber&& other) noexcept { swap(other); }
	f8_fiber& operator=(f8_fiber&& other) noexcept
	{
		if (this != &other)
		{
			f8_fiber tmp { std::move(other) };
			swap(tmp);
		}
		return *this;
	}

	f8_fiber(const f8_fiber& other) noexcept = delete;
	f8_fiber& operator=(const f8_fiber& other) noexcept = delete;

	f8_fiber resume() && noexcept { return { jump_fcontext(std::exchange(_fctx, nullptr), nullptr).ctx }; }
	f8_fiber resume() & noexcept { return std::move(*this).resume(); }

	/*! Resume given fiber
	 \param what rvalue fiber to resume */
	static void resume(f8_fiber&& what) noexcept
	{
		if (what)
			what = std::move(std::move(what).resume());
	}
	/*! Resume given fiber
	 \param what lvalue fiber to resume */
	static void resume(f8_fiber& what) noexcept
	{
		if (what)
			what = std::move(what.resume());
	}

	/*! Resume given fiber with given fn
	 \tparam Fn function type or method to invoke
	 \param fn function
	 \return f8_fiber */
	template<typename Fn>
	f8_fiber resume_with(Fn&& fn) && noexcept
	{
		auto p { std::forward<Fn>(fn) };
		return { ontop_fcontext(std::exchange(_fctx, nullptr), &p, [](fcontext_transfer_t trf) noexcept ->fcontext_transfer_t // fiber_ontop
		{
			 auto pfunc { *static_cast<Fn *>(trf.data) };
			 // execute function, pass fiber via reference
			 f8_fiber fb { pfunc(f8_fiber{trf.ctx}) };
			 return { std::exchange(fb._fctx, nullptr), nullptr };
		}).ctx };
	}

	/*! Resume given fiber with new function
	 \tparam Fn function type or method to invoke
	 \param what rvalue fiber to resume
	 \param fn function */
	template<typename Fn>
	static void resume_with(f8_fiber&& what, Fn&& fn) noexcept
	{
		if (what)
			what = std::move(std::move(what).resume_with(fn));
	}

	/*! Resume given fiber with new function, with function arguments passed to std::bind; this allows you to simply pass
	  the bind arguments directly without needed to call bind yourself
	 \tparam Fn function type or method to invoke
    \tparam Args to pass to method (via bind)
	 \param what rvalue fiber to resume
	 \param fn function
    \param args to pass */
	template<typename Fn, typename... Args, std::enable_if_t<!std::is_bind_expression_v<Fn>,int> = 0>
	static void resume_with(f8_fiber&& what, Fn&& fn, Args&&... args) noexcept
	{
		if (what)
			what = std::move(std::move(what).resume_with(std::bind(std::forward<Fn>(fn), std::forward<Args>(args)...)));
	}

	bool joinable() const noexcept { return _fctx; }
	explicit operator bool() const noexcept { return _fctx; }
	bool operator! () const noexcept { return _fctx == nullptr; }
	bool operator< (const f8_fiber& other) const noexcept { return _fctx < other._fctx; }

	void swap(f8_fiber& other) noexcept { std::swap(_fctx, other._fctx); }
	static void swap(f8_fiber& l, f8_fiber& r) noexcept { l.swap(r); }

	template<typename charT, class traitsT>
	friend std::basic_ostream<charT, traitsT>& operator<<(std::basic_ostream<charT, traitsT>& os, const f8_fiber& what)
	{
		if (what._fctx)
			return os << what._fctx << " (" << what._rec << ',' << reinterpret_cast<const void* const&>(what._dealloc) << ')';
		return os << "{not-a-fiber}";
	}

	static fcontext_transfer_t jump_fcontext(const fcontext_t to, void *vp);
	static fcontext_t make_fcontext(void *sp, size_t size, void (*fn)(fcontext_transfer_t));
	static fcontext_transfer_t ontop_fcontext(const fcontext_t to, void *vp, fcontext_transfer_t (*fn)(fcontext_transfer_t));

	/// unique fiber id
	class f8_fiber_id
	{
		const fcontext_t impl_{ nullptr };

	public:
		f8_fiber_id() = default;
		explicit f8_fiber_id(const fcontext_t impl) noexcept : impl_{ impl } {}

#if __cplusplus >= 202002L
		constexpr auto operator<=>(const f8_fiber_id& other) const noexcept { return impl_ <=> other.impl_; }
#else
		constexpr bool operator==(const f8_fiber_id& other) const noexcept { return impl_ == other.impl_; }
		constexpr bool operator!=(const f8_fiber_id& other) const noexcept { return impl_ != other.impl_; }
		constexpr bool operator<(const f8_fiber_id& other) const noexcept { return impl_ < other.impl_; }
		constexpr bool operator>(const f8_fiber_id& other) const noexcept { return other.impl_ < impl_; }
		constexpr bool operator<=(const f8_fiber_id& other) const noexcept { return !(*this > other); }
		constexpr bool operator>=(const f8_fiber_id& other) const noexcept { return !(*this < other); }
#endif

		template<typename charT, class traitsT>
		friend std::basic_ostream<charT, traitsT>& operator<<(std::basic_ostream<charT, traitsT>& os, const f8_fiber_id& what)
		{
			if (what.impl_)
				return os << what.impl_;
			return os << "{not-valid (nullptr)}";
		}

		constexpr explicit operator bool() const noexcept { return impl_ != nullptr; }
		constexpr bool operator!() const noexcept { return impl_ == nullptr; }
	};

	f8_fiber_id get_id() const noexcept { return f8_fiber_id(_fctx); }
};

//-----------------------------------------------------------------------------------------
asm(R"(.text
.align 16
.type _ZN4FIX88f8_fiber13jump_fcontextEPvS1_,@function
_ZN4FIX88f8_fiber13jump_fcontextEPvS1_:
	leaq  -0x38(%rsp), %rsp
	stmxcsr  (%rsp)
	fnstcw   0x4(%rsp)
	movq  %r12,0x8(%rsp)
	movq  %r13,0x10(%rsp)
	movq  %r14,0x18(%rsp)
	movq  %r15,0x20(%rsp)
	movq  %rbx,0x28(%rsp)
	movq  %rbp,0x30(%rsp)
	movq  %rsp,%rax
	movq  %rdi,%rsp
	movq  0x38(%rsp),%r8
	ldmxcsr (%rsp)
	fldcw   0x4(%rsp)
	movq  0x8(%rsp),%r12
	movq  0x10(%rsp),%r13
	movq  0x18(%rsp),%r14
	movq  0x20(%rsp),%r15
	movq  0x28(%rsp),%rbx
	movq  0x30(%rsp),%rbp
	leaq  0x40(%rsp),%rsp
	movq  %rsi,%rdx
	movq  %rax,%rdi
	jmp  *%r8
.size _ZN4FIX88f8_fiber13jump_fcontextEPvS1_,.-_ZN4FIX88f8_fiber13jump_fcontextEPvS1_
.type _ZN4FIX88f8_fiber13make_fcontextEPvmPFvNS_19fcontext_transfer_tEE,@function
_ZN4FIX88f8_fiber13make_fcontextEPvmPFvNS_19fcontext_transfer_tEE:
	movq  %rdi,%rax
	andq  $-16,%rax
	leaq  -0x40(%rax),%rax
	movq  %rdx,0x28(%rax)
	stmxcsr (%rax)
	fnstcw  0x4(%rax)
	leaq  trampoline(%rip),%rcx
	movq  %rcx,0x38(%rax)
	leaq  finish(%rip),%rcx
	movq  %rcx,0x30(%rax)
	ret
trampoline:
	push %rbp
	jmp *%rbx
finish:
	xorq  %rdi,%rdi
	call  _exit@PLT
	hlt
.size _ZN4FIX88f8_fiber13make_fcontextEPvmPFvNS_19fcontext_transfer_tEE,.-_ZN4FIX88f8_fiber13make_fcontextEPvmPFvNS_19fcontext_transfer_tEE
.type _ZN4FIX88f8_fiber14ontop_fcontextEPvS1_PFNS_19fcontext_transfer_tES2_E,@function
_ZN4FIX88f8_fiber14ontop_fcontextEPvS1_PFNS_19fcontext_transfer_tES2_E:
	movq  %rdx,%r8
	leaq  -0x38(%rsp),%rsp
	stmxcsr (%rsp)
	fnstcw  0x4(%rsp)
	movq  %r12,0x8(%rsp)
	movq  %r13,0x10(%rsp)
	movq  %r14,0x18(%rsp)
	movq  %r15,0x20(%rsp)
	movq  %rbx,0x28(%rsp)
	movq  %rbp,0x30(%rsp)
	movq  %rsp,%rax
	movq  %rdi,%rsp
	ldmxcsr (%rsp)
	fldcw   0x4(%rsp)
	movq  0x8(%rsp),%r12
	movq  0x10(%rsp),%r13
	movq  0x18(%rsp),%r14
	movq  0x20(%rsp),%r15
	movq  0x28(%rsp),%rbx
	movq  0x30(%rsp),%rbp
	leaq  0x38(%rsp),%rsp
	movq  %rsi,%rdx
	movq  %rax,%rdi
	jmp  *%r8
.size _ZN4FIX88f8_fiber14ontop_fcontextEPvS1_PFNS_19fcontext_transfer_tES2_E,.-_ZN4FIX88f8_fiber14ontop_fcontextEPvS1_PFNS_19fcontext_transfer_tES2_E
)");

#define f8_yield(f) f8_fiber::resume(f)
#define f8_yield_with(f,fn,...) f8_fiber::resume_with(std::move(f), fn, __VA_ARGS__)

//-----------------------------------------------------------------------------------------
} // namespace FIX8

#endif // FIX8_FIBER_HPP_

