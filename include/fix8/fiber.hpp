//-----------------------------------------------------------------------------------------
// fiber (header only)
// Copyright (C) 2022-23 Fix8 Market Technologies Pty Ltd
//   by David L. Dight
// see https://github.com/fix8mt/fiber
//
// Lightweight header-only stackful per-thread fiber
//		with built-in roundrobin scheduler x86_64 / linux only
//
// Distributed under the Boost Software License, Version 1.0 August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//----------------------------------------------------------------------------------------
#ifndef FIX8_FIBER_HPP_
#define FIX8_FIBER_HPP_

//----------------------------------------------------------------------------------------
#if !defined(__linux__) || !defined(__x86_64__)
#error "this fiber implementation only runs on x86_64/Linux"
#endif

//----------------------------------------------------------------------------------------
#include <iostream>
#include <iomanip>
#include <type_traits>
#include <future>
#include <deque>
#include <array>
#include <chrono>
#include <algorithm>
#include <cstring>
#include <string>
#include <string_view>
#include <functional>
#include <stdexcept>
#include <ranges>
#include <bitset>
#include <mutex>
#include <utility>
#include <thread>
#include <concepts>
#include <condition_variable>
#include <set>
#include <unordered_set>
#include <atomic>

#include <fcntl.h>
#include <sys/resource.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>
#include <pthread.h>

//-----------------------------------------------------------------------------------------
// default fiber stack size; define in your app to override or set in ctor
#if !defined FIX8_FIBER_DEFSTKSZ
# define FIX8_FIBER_DEFSTKSZ 131072 // 128kb recommended
#endif
// default fiber name length
#if !defined FIX8_FIBER_FIBERNAMELEN
# define FIX8_FIBER_FIBERNAMELEN 16 // including null terminator
#endif

// define FIBER_NO_INSTRUMENTATION to disable instrumentation and printing
// if not defined, all instrumentation and printing is enabled (default)
#if !defined FIBER_NO_INSTRUMENTATION
# define FIX8_FIBER_INSTRUMENTATION_
#endif
// define FIBER_NO_MULTITHREADING to disable multi-threading support
// if not defined, multi-threading support is enabled (default)
#if !defined FIBER_NO_MULTITHREADING
# define FIX8_FIBER_MULTITHREADING_
#endif

//-----------------------------------------------------------------------------------------
namespace FIX8 {

//-----------------------------------------------------------------------------------------
#if defined FIX8_FIBER_MULTITHREADING_ && !defined f8_spin_lock && !defined f8_scoped_lock_impl
class f8_spin_lock final
{
	std::atomic_flag _sl;

public:
	void lock() noexcept { _sl.wait(true); } // std::memory_order_seq_cst
	void unlock() noexcept { _sl.clear(); } // std::memory_order_seq_cst
};

template<typename T>
class f8_scoped_lock_impl
{
	T& _local_mutex;

public:
	f8_scoped_lock_impl(T& mutex) noexcept : _local_mutex(mutex) { _local_mutex.lock(); }
	~f8_scoped_lock_impl() noexcept { release(); }
	void release() noexcept { _local_mutex.unlock(); }

	f8_scoped_lock_impl() = delete;
	f8_scoped_lock_impl(const f8_scoped_lock_impl&) = delete;
	f8_scoped_lock_impl& operator=(const f8_scoped_lock_impl&) = delete;
};

using f8_scoped_spin_lock = f8_scoped_lock_impl<f8_spin_lock>;
#endif

//-----------------------------------------------------------------------------------------
/// unique fiber id
class fiber_id
{
	const void *_ptr{};

public:
	fiber_id() noexcept = default;
	constexpr explicit fiber_id(const void *ptr) noexcept : _ptr{ ptr } {}

#if defined FIX8_FIBER_INSTRUMENTATION_
	template<typename charT, class traitsT> // TODO replace with std::format
	friend std::basic_ostream<charT, traitsT>& operator<<(std::basic_ostream<charT, traitsT>& os, const fiber_id& what)
	{
		return what._ptr ? (os << std::dec << reinterpret_cast<uint64_t>(what._ptr) % 10000) : (os << "NaF");
	}

	std::string to_string() const noexcept
	{
		std::ostringstream ostr;
		ostr << *this;
		return ostr.str();
	}
#endif
	constexpr auto operator<=>(const fiber_id& other) const noexcept { return _ptr <=> other._ptr; }
	constexpr bool operator!() const noexcept { return _ptr == nullptr; }
	constexpr explicit operator bool() const noexcept { return !operator!(); }
	friend struct std::hash<fiber_id>;
};

//-----------------------------------------------------------------------------------------
enum class global_fiber_flags { retain, fairshare, hidedetached, skipmain, termthrow, excepthandling, count };

//-----------------------------------------------------------------------------------------
// used by FIX8::this_fiber
struct f8_this_fiber
{
	inline static fiber_id get_id() noexcept;
#if defined FIX8_FIBER_INSTRUMENTATION_
	inline static fiber_id get_prev_id() noexcept;
#endif
	inline static fiber_id get_pid() noexcept;
	inline static std::string_view name(std::string_view what) noexcept;
	inline static std::string_view name() noexcept;
#if defined FIX8_FIBER_MULTITHREADING_
	inline static void move(std::thread::id id);
#endif
	inline static void yield() noexcept;
	inline static void resume_main() noexcept;
	inline static bool schedule_main() noexcept;
	template<typename Clock, typename Duration>
	static void sleep_until(const std::chrono::time_point<Clock, Duration>& sltime);
	template<typename Rep, typename Period>
	static void sleep_for(const std::chrono::duration<Rep, Period>& retime);
};

using fiber_base_ptr = std::shared_ptr<class fiber_base>;
using fiber_queue = std::deque<fiber_base_ptr>;
using fiber_set = std::unordered_set<fiber_base_ptr>;
using fiber_ptr = std::unique_ptr<class fiber>;

// used by FIX8::fibers
struct f8_fibers
{
	inline static int size() noexcept;
	inline static int size_accurate() noexcept;
	inline static int size_finished() noexcept;
	inline static int size_detached() noexcept;
	inline static bool has_fibers() noexcept;
	inline static bool has_finished() noexcept;
	inline static bool has_flag(global_fiber_flags flag) noexcept;
	inline static void set_flag(global_fiber_flags flag) noexcept;
	inline static void reset_flag(global_fiber_flags flag) noexcept;
	inline static void sort() noexcept;
	inline static void wait_all() noexcept;
	inline static std::exception_ptr get_exception_ptr() noexcept;
	template<std::invocable Fn>
	static void wait_all(Fn&&) noexcept;
	inline static bool terminating() noexcept;
	inline static void wait_any() noexcept;
	template<std::invocable Fn>
	static void wait_any(Fn&&) noexcept;
#if defined FIX8_FIBER_INSTRUMENTATION_
	inline static void print(std::ostream& os) noexcept;
#endif
	inline static int kill_all() noexcept;
#if defined FIX8_FIBER_MULTITHREADING_
	inline static void move(std::thread::id id, fiber_base_ptr ptr);
	inline static void move(std::thread::id id, const class fiber& fb);
#endif
};

//-----------------------------------------------------------------------------------------
struct fiber_error : std::system_error
{
	using std::system_error::system_error;
};

enum class launch { dispatch, post, none }; // from boost::fiber

//-----------------------------------------------------------------------------------------
/// ABC stack
class alignas(16) f8_stack
{
protected:
	char *_ptr{};
	std::size_t _size{FIX8_FIBER_DEFSTKSZ};

public:
	constexpr f8_stack() noexcept = default;
	virtual ~f8_stack() { deallocate(); }
	f8_stack(f8_stack&&) noexcept = default;

	f8_stack(f8_stack&) = delete;
	f8_stack& operator=(f8_stack&) = delete;

	virtual char *allocate(std::size_t size) = 0;
	virtual void deallocate() noexcept { _ptr = nullptr; }
	constexpr std::size_t size() const noexcept { return _size; }

#if defined FIX8_FIBER_INSTRUMENTATION_
	friend std::ostream& operator<<(std::ostream& os, const f8_stack& what)
	{
		return os << reinterpret_cast<void *>(what._ptr) << ' ' << what._size;
	}
#endif
};

using f8_stack_ptr = std::unique_ptr<f8_stack>;

//-----------------------------------------------------------------------------------------
/// Anonymous memory mapped stack
class f8_fixedsize_mapped_stack final : public f8_stack
{
public:
	char *allocate(std::size_t size) override
	{
		if (!_ptr)
		{
			const auto PageSize { static_cast<size_t>(sysconf(_SC_PAGESIZE)) };
			const std::size_t pages { (size + PageSize - 1) / PageSize }; // calculate pages required
			_size = (pages + 1) * PageSize; // add a page at bottom for guard-page

			if (void *vp { ::mmap(0, _size, PROT_READ | PROT_WRITE, MAP_PRIVATE |
#if defined(MAP_STACK)
				MAP_ANON | MAP_STACK,
#elif defined(MAP_ANON)
				MAP_ANON,
#else
				MAP_ANONYMOUS,
#endif
				-1, 0) }; vp == MAP_FAILED)
					throw std::bad_alloc();
			else
				_ptr = static_cast<char *>(vp);
		}
		return _ptr;
	}

	void deallocate() noexcept override
	{
		if (_ptr)
			::munmap(_ptr, _size);
		f8_stack::deallocate();
	}
};

//-----------------------------------------------------------------------------------------
/// Simple heap based stack
class f8_fixedsize_heap_stack final : public f8_stack
{
public:
	char *allocate(std::size_t size) override
	{
		if (!_ptr)
		{
			_size = size & ~0xff;
			_ptr = static_cast<char *>(::operator new(_size));
		}
		return _ptr;
	}
	void deallocate() noexcept override
	{
		delete _ptr;
		f8_stack::deallocate();
	}
};

//-----------------------------------------------------------------------------------------
/// Placement stack
class f8_fixedsize_placement_stack final : public f8_stack
{
public:
	constexpr f8_fixedsize_placement_stack(char *top, size_t offs=0) noexcept { _ptr = top + offs; }
	char *allocate(std::size_t size) noexcept override
	{
		_size = size;
		return _ptr;
	}
};

//-----------------------------------------------------------------------------------------
template<typename T=f8_fixedsize_heap_stack, typename... Args>
requires std::derived_from<T, f8_stack>
constexpr f8_stack_ptr make_stack(Args&&... args)
{
	return f8_stack_ptr{new T(std::forward<Args>(args)...)};
}

enum class stack_type { heap, mapped, placement };

template<stack_type type, typename... Args>
constexpr f8_stack_ptr make_stack(Args&&... args)
{
	using enum stack_type;
	if constexpr (type == heap)
		return make_stack(std::forward<Args>(args)...);
	if constexpr (type == mapped)
		return make_stack<f8_fixedsize_mapped_stack>(std::forward<Args>(args)...);
	if constexpr (type == placement)
		return make_stack<f8_fixedsize_placement_stack>(std::forward<Args>(args)...);
}

//-----------------------------------------------------------------------------------------
struct alignas(16) fiber_params final
{
	const char name[FIX8_FIBER_FIBERNAMELEN]{};
	int launch_order{99};
	bool join{};
	// these next values can't be modified once the fiber has been created
	const size_t stacksz{FIX8_FIBER_DEFSTKSZ};
	const launch policy{launch::post};
	alignas(16) f8_stack_ptr stack{make_stack<stack_type::heap>()};
};

//-----------------------------------------------------------------------------------------
class alignas(64) fiber_base
{
	uintptr_t *_stk; // top of fiber stack
	const uintptr_t _stacksz;
	uintptr_t *const _stk_alloc{}; // allocated stack memory
	fiber_params _params;
	const fiber_id _pfid; // parent fiber
#if defined FIX8_FIBER_INSTRUMENTATION_
	fiber_id _prev_fiber;
	unsigned _ctxswtchs{};
	std::chrono::nanoseconds _extime{}, _exdelta{};
#endif
	enum fiber_flags { main, finished, suspended, dispatched, detached, notstarted,
		joinonexit, transfer, moved, fiber_flags_count }; // mfspdnjtv
	std::bitset<fiber_flags_count> _flags;
	std::chrono::steady_clock::time_point _tp{};
	std::condition_variable _cv_join;
	std::mutex _join_mutex;

	template<typename Wrapper>
	static void trampoline(void *ptr) noexcept;

	// [asm] stack switch routine
	static void coroswitch(fiber_base *old, fiber_base *newer) noexcept asm("_coroswitch");

	static size_t get_default_stacksz()
	{
		static thread_local const auto sz([]()
		{
			size_t size{};
			if (pthread_attr_t attr; pthread_attr_init(&attr) == 0)
				pthread_attr_getstacksize(&attr, &size);
			return size;
		}());
		return sz;
	}

	template<typename Fn>
	struct callable_wrapper
	{
		std::decay_t<Fn> _func;
		constexpr callable_wrapper(Fn&& func) noexcept : _func(std::forward<Fn>(func)) {}
	};

	// stack: trampoline,fiber(wrapper func),rdi,rbp,r12,r13,r14,r15,fpu/sse flags
	// TODO: win64 xmm6 - xmm15
	// TODO other architectures
	template<typename Fn>
	void setup_continuation(Fn&& func) noexcept
	{
		_stk = _stk_alloc + _stacksz / sizeof(uintptr_t) - 1; // set top of stack
		*--_stk = reinterpret_cast<uintptr_t>(trampoline<callable_wrapper<Fn>>);
		*--_stk = reinterpret_cast<uintptr_t>(new (reinterpret_cast<char*>(_stk_alloc) + sizeof(fiber_base))
			callable_wrapper(std::forward<Fn>(func))); // store at bottom of stack
		std::memset(_stk - 6, 0x0, 6 * sizeof(uintptr_t)); // zero: rdi,rbp,r12,r13,r14,r15
		_stk -= 7; // include flags
		asm("stmxcsr %0" : "=m" (*reinterpret_cast<uint32_t*>(_stk))); // preserve lower dword
		asm("fnstcw %0"  : "=m" (*(reinterpret_cast<uint32_t*>(_stk) + 1))); // preserve upper dword, lower word
	}

	fiber_base() noexcept : _stacksz{get_default_stacksz()},
		_params{.name="main",.stacksz=_stacksz,.stack=f8_stack_ptr()},
#if defined FIX8_FIBER_INSTRUMENTATION_
		_ctxswtchs{1},
#endif
		_flags{1 << main} {}

public:
	template<std::invocable Fn>
	fiber_base(fiber_params&& params, Fn&& func, uintptr_t *sp, fiber_id parent) noexcept
		: _stacksz(params.stacksz), _stk_alloc(sp), _params(std::move(params)), _pfid(parent),
			_flags{(1 << notstarted) | (_params.join ? (1 << joinonexit) : 0ULL)}
	{
		setup_continuation(std::forward<Fn>(func));
	}

	~fiber_base() noexcept = default;

	constexpr fiber_id get_id() const noexcept { return fiber_id(!is_main() ? this : nullptr); }
#if defined FIX8_FIBER_INSTRUMENTATION_
	constexpr fiber_id get_prev_id() const noexcept { return _prev_fiber; }
	std::string get_flags_as_string() const noexcept;
#endif
	constexpr fiber_id get_pid() const noexcept { return _pfid; }

	std::string_view name(std::string_view what) noexcept
	{
		if (!what.empty() && !is_main()) // you can't name main
		{
			const auto len { what.size() > FIX8_FIBER_FIBERNAMELEN - 1 ? FIX8_FIBER_FIBERNAMELEN - 1 : what.size() };
			auto *ptr { const_cast<char*>(&_params.name[0]) }; // override const
			std::memcpy(ptr, what.data(), len);
			*(ptr + len) = 0;
		}
		return _params.name;
	}
	constexpr std::string_view name() const noexcept { return _params.name; }
	int order(int ord) noexcept { return _params.launch_order = ord; }

	constexpr bool joinable() const noexcept { return !_flags[finished]; };
	constexpr bool is_main() const noexcept { return _flags[main]; };
	constexpr bool is_detached() const noexcept { return _flags[detached]; };
	constexpr bool is_suspended() const noexcept { return _flags[suspended]; };
	constexpr bool is_joinonexit() const noexcept { return _flags[joinonexit]; };
	constexpr bool is_dispatched() const noexcept { return _flags[dispatched]; };
	constexpr bool is_transfering() const noexcept { return _flags[transfer]; };
	constexpr bool is_moved() const noexcept { return _flags[moved]; };

#if defined FIX8_FIBER_INSTRUMENTATION_
	friend std::ostream& operator<<(std::ostream& os, const fiber_base& what);
	friend class fiber_monitor;
#endif
	friend class fiber;
	friend class jfiber;
	friend f8_this_fiber;
	friend f8_fibers;
};

//-----------------------------------------------------------------------------------------
// static void fiber_base::coroswitch(fiber_base *old, fiber_base *newer) noexcept; //aka _coroswitch
// TODO other architectures
asm(R"(.text
.align 16
.type _coroswitch,@function
_coroswitch:
	cmpq %rdi,%rsi			/* prevent self-switch */
	jne _doswitch
	ret
_doswitch:
	subq $0x40,%rsp
   stmxcsr (%rsp)			/* save fpu/mx/sse flags */
   fnstcw  4(%rsp)
	movq %r15,8(%rsp)
	movq %r14,8*2(%rsp)
	movq %r13,8*3(%rsp)
	movq %r12,8*4(%rsp)
	movq %rbx,8*5(%rsp)
	movq %rbp,8*6(%rsp)
	movq %rdi,8*7(%rsp)

	movq %rsp,(%rdi)		/* save old user stack */
	movq (%rsi),%rsp		/* restore new user stack */

   ldmxcsr (%rsp)			/* restore fpu/mx/sse flags */
   fldcw  4(%rsp)
   movq 8(%rsp),%r15
   movq 8*2(%rsp),%r14
   movq 8*3(%rsp),%r13
   movq 8*4(%rsp),%r12
   movq 8*5(%rsp),%rbx
   movq 8*6(%rsp),%rbp
   movq 8*7(%rsp),%rdi
	movq 8*8(%rsp),%r8	/* get ret address */
	addq $0x48,%rsp		/* one extra qword for ret */
   jmp *%r8					/* jump to new location */
.size _coroswitch,.-_coroswitch
.section .note.GNU-stack,"",%progbits
)");

//-----------------------------------------------------------------------------------------
class alignas(16) fiber
{
	using enum std::errc;
	enum class exit_path { dtor, tramp };
	fiber_base_ptr _ctx;

#define GetVars() auto& [uni, sch, cur, man, trm, now, flg, fin, ep] { fiber::get_vars() }
#define ConstGetVars() const GetVars()
#define GetVar(x) fiber::get_vars().x
#define ConstGetVar(x) static_cast<const decltype(fiber::cvars::x)&>(GetVar(x))

public:
	struct alignas(64) cvars final
	{
		fiber_set _uniq;
		fiber_queue _sched;
		fiber_base_ptr _curr;
		const fiber_base_ptr _main;
		bool _term;
		std::chrono::time_point<std::chrono::system_clock> _now;
		std::bitset<static_cast<int>(global_fiber_flags::count)> _gflags;
		int _finished;
		std::exception_ptr _eptr;

		~cvars() noexcept;

		fiber_base_ptr operator[](unsigned idx) const noexcept { return idx < _sched.size() ? _sched[idx] : fiber_base_ptr(); }
		size_t size() const noexcept { return _sched.size(); }
	};

#if defined FIX8_FIBER_MULTITHREADING_
	class alignas(64) all_cvars final
	{
		mutable f8_spin_lock _tvs_spl;
		std::unordered_map<std::thread::id, cvars *> _tvs;
		std::unordered_multimap<std::thread::id, fiber_base_ptr> _trf;

	public:
		all_cvars() noexcept = default;
		all_cvars(const all_cvars&) = delete;
		all_cvars(all_cvars&&) = delete;
		all_cvars& operator=(const all_cvars&) = delete;
		all_cvars& operator=(all_cvars&&) = delete;

		size_t size() const
		{
			f8_scoped_spin_lock guard(_tvs_spl);
			return _tvs.size();
		}
		size_t count() const
		{
			size_t result{};
			f8_scoped_spin_lock guard(_tvs_spl);
			for (const auto& pp : _tvs)
				result += pp.second->size();
			return result;
		}
		bool insert(std::thread::id id, cvars *var)
		{
			f8_scoped_spin_lock guard(_tvs_spl);
			return _tvs.emplace(id, var).second;
		}
		bool remove(std::thread::id id)
		{
			f8_scoped_spin_lock guard(_tvs_spl);
			return _tvs.erase(id) > 0;
		}
		cvars *get(std::thread::id id) // ptr is not thread safe
		{
			f8_scoped_spin_lock guard(_tvs_spl);
			auto result { _tvs.find(id) };
			return result != _tvs.end() ? result->second : nullptr;
		}
		const cvars *get(std::thread::id id) const // ptr is not thread safe
		{
			f8_scoped_spin_lock guard(_tvs_spl);
			auto result { _tvs.find(id) };
			return result != _tvs.cend() ? result->second : nullptr;
		}
		void queue_move(std::thread::id id, fiber_base_ptr ptr) // transfer from this thread to other thread
		{
			if (id == std::this_thread::get_id())
				throw fiber_error { std::make_error_code(invalid_argument),
					"target thread same as source thread" };
			else if (!ptr)
				throw fiber_error { std::make_error_code(invalid_argument),
					"invalid fiber" };
			else if (id == std::thread::id()) // empty id
				throw fiber_error { std::make_error_code(invalid_argument),
					"invalid id" };
			else if (f8_scoped_spin_lock guard(_tvs_spl); _tvs.find(id) != _tvs.cend())
			{
				ptr->_flags.set(fiber_base::transfer);
				GetVar(_uniq).erase(ptr);
				_trf.emplace(id, ptr);
				guard.release();
				f8_this_fiber::yield();
			}
			/*else
				throw fiber_error { std::make_error_code(invalid_argument),
					"thread not running" };*/
		}
		int move() // process transfers to this thread
		{
			int result{};
			f8_scoped_spin_lock guard(_tvs_spl);
			if (auto rng { _trf.equal_range(std::this_thread::get_id()) }; rng.first != rng.second)
			{
				GetVars();
				do
				{
					uni.insert(rng.first->second);
					sch.push_back(rng.first->second);
					++result;
				}
				while (++rng.first != rng.second);
				sort_queue(sch);
				_trf.erase(std::this_thread::get_id());
			}
			return result;
		}
	};
#endif

private:
#if defined FIX8_FIBER_MULTITHREADING_
	static all_cvars& get_all_cvars() noexcept
	{
		static all_cvars _allcvars; // per process singleton
		return _allcvars;
	}
#endif

	static cvars& get_vars() noexcept
	{
		static thread_local fiber_base _main_ctx;
		static thread_local fiber_base_ptr _main_ctx_ptr { fiber_base_ptr(&_main_ctx, [](auto *) {}) };
		static thread_local cvars _cvars // per thread singleton
		{
			._uniq={_main_ctx_ptr},._curr=_main_ctx_ptr,._main=_main_ctx_ptr,
			._term=false,._now=std::chrono::system_clock::now()
		};
#if defined FIX8_FIBER_MULTITHREADING_
		static thread_local bool _register_cvars([]() // register this thread
		{
			return get_all_cvars().insert(std::this_thread::get_id(), &_cvars);
		}());
#endif
		return _cvars;
	}

	static void fiber_exit(exit_path epath)
	{
		std::ostringstream eostr;
#if defined FIX8_FIBER_INSTRUMENTATION_
		if (!f8_this_fiber::name().empty())
			eostr << std::quoted(f8_this_fiber::name(), '\'');
		else
#endif
			eostr << "fiber";
#if defined FIX8_FIBER_INSTRUMENTATION_
		if (f8_this_fiber::get_id())
			eostr << " (fid=" << f8_this_fiber::get_id() << ')';
#endif
		eostr << " has exited (" << (epath == exit_path::dtor ? "dtor" : "trampoline") << ").";
		if (!f8_fibers::has_flag(global_fiber_flags::termthrow))
		{
			std::cerr << eostr.str() << " Terminating application." << std::endl;
			std::terminate();
		}
		if (f8_fibers::has_flag(global_fiber_flags::excepthandling))
			GetVar(_eptr) = std::make_exception_ptr(std::logic_error(eostr.str()));
	}
	static void sort_queue(fiber_queue& sch) noexcept
	{
		std::stable_sort(sch.begin(), sch.end(), [](const fiber_base_ptr& p1, const fiber_base_ptr& p2)
		{
			return p1->_params.launch_order < p2->_params.launch_order;
		});
	}

public:
	template<typename Fn, typename... Args>
	requires std::invocable<Fn&&, Args...> && (!std::is_bind_expression_v<Fn>)
	constexpr fiber(Fn&& func, Args&&... args)
		: fiber({}, std::bind(std::forward<Fn>(func), std::forward<Args>(args)...)) {}

	template<typename Fn, typename... Args>
	requires std::invocable<Fn&&, Args...> && (!std::is_bind_expression_v<Fn>)
	constexpr fiber(fiber_params&& params, Fn&& func, Args&&... args)
		: fiber(std::forward<fiber_params>(params), std::bind(std::forward<Fn>(func), std::forward<Args>(args)...)) {}

	template<std::invocable Fn>
	constexpr fiber(Fn&& func) : fiber({}, std::forward<Fn>(func)) {}

	template<std::invocable Fn>
	constexpr fiber(fiber_params&& params, Fn&& func)
	{
		uintptr_t *sp { reinterpret_cast<uintptr_t *>(params.stack->allocate(params.stacksz)) };
		GetVars();
		_ctx.reset(new (reinterpret_cast<char*>(sp))
			fiber_base(std::forward<fiber_params>(params), std::forward<Fn>(func), sp, cur->get_id()), [](auto *) {});
		uni.insert(_ctx);
		sch.push_back(_ctx);
		sort_queue(sch);
		if (_ctx->_params.policy == launch::dispatch)
		{
			_ctx->_flags.set(fiber_base::dispatched);
			resume();
		}
	}

	fiber(const fiber&) = delete;
	fiber& operator=(const fiber&) = delete;

	~fiber()
	{
		if (_ctx)
		{
			if (joinable() && !is_detached() && !is_moved() && !is_transfering())
			{
				if (is_joinonexit())
					join();
				else
					fiber_exit(exit_path::dtor);
			}
			else if (is_moved())
				_ctx->_flags.reset(fiber_base::moved);
		}
	}

	fiber(fiber_base_ptr from) noexcept : _ctx(std::move(from)) {}
	fiber(fiber&& other) noexcept
	{
		*this = std::move(other);
	}
	fiber& operator=(fiber&& other) noexcept
	{
		_ctx = std::move(other._ctx);
		return *this;
	}

	fiber& set_joinonexit(bool set=true) noexcept
	{
		(_ctx->_params.join = set) ? _ctx->_flags.set(fiber_base::joinonexit)
											: _ctx->_flags.reset(fiber_base::joinonexit);
		return *this;
	}

	fiber& set_params(std::string_view nm, int lo=99, bool jn=false) noexcept
	{
		name(nm);
		order(lo);
		set_joinonexit(jn);
		return *this;
	}

	void join()
	{
		if (auto& cur { GetVar(_curr) }; _ctx != cur)
		{
			if (!joinable())
				throw fiber_error { std::make_error_code(invalid_argument),
					"fiber not joinable" };
			else
			{
				std::unique_lock jlock(_ctx->_join_mutex);
				_ctx->_cv_join.wait(jlock, [this]
				{
					f8_this_fiber::yield();
					return !joinable();
				});
			}
		}
		else
			throw fiber_error { std::make_error_code(resource_deadlock_would_occur),
				"fiber cannot self-join" };
	}
	void join_if()
	{
		if (joinable())
			join();
	}

	void detach()
	{
		if (is_detached())
			throw fiber_error { std::make_error_code(invalid_argument),
				"fiber already detached" };
		else if (!joinable() && !is_dispatched())
			throw fiber_error { std::make_error_code(invalid_argument),
				"fiber not joinable" };
		else
			_ctx->_flags.set(fiber_base::fiber_flags::detached);
	}

	void suspend()
	{
		if (!joinable())
			throw fiber_error { std::make_error_code(invalid_argument),
				"fiber not joinable" };
		else if (is_detached())
			throw fiber_error { std::make_error_code(invalid_argument),
				"cannot suspend detached fiber" };
		else if (is_suspended())
			throw fiber_error { std::make_error_code(invalid_argument),
				"fiber already suspended" };
		_ctx->_tp = decltype(_ctx->_tp){};
		_ctx->_flags.set(fiber_base::suspended);
	}
	void unsuspend()
	{
		if (!joinable())
			throw fiber_error { std::make_error_code(invalid_argument),
				"fiber not joinable" };
		else if (is_detached())
			throw fiber_error { std::make_error_code(invalid_argument),
				"cannot unsuspend detached fiber" };
		else if (!is_suspended())
			throw fiber_error { std::make_error_code(invalid_argument),
				"fiber not suspended" };
		_ctx->_tp = decltype(_ctx->_tp){};
		_ctx->_flags.reset(fiber_base::suspended);
	}
	void kill()
	{
		if (!joinable())
			throw fiber_error { std::make_error_code(invalid_argument),
				"fiber not joinable" };
		else if (is_detached())
			throw fiber_error { std::make_error_code(invalid_argument),
				"cannot kill detached fiber" };
		_ctx->_flags.set(fiber_base::finished); // will not be scheduled again
		++GetVar(_finished);
	}

	bool schedule(bool check=true)
	{
		if (check)
		{
			if (!joinable())
				throw fiber_error { std::make_error_code(invalid_argument),
					"fiber not joinable" };
			else if (is_detached())
				throw fiber_error { std::make_error_code(invalid_argument),
					"cannot schedule detached fiber" };
		}
		GetVars();
		if (cur == _ctx)
			throw fiber_error { std::make_error_code(resource_deadlock_would_occur),
				"fiber cannot schedule itself" };
		else if (uni.contains(_ctx))
		{
			if (auto& front { sch.front() }; front != _ctx)
			{
				for (auto itr { sch.begin() }; itr != sch.end(); ++itr)
				{
					if (*itr == _ctx)
					{
						itr->swap(front); // swap next with specified fiber
						break;
					}
				}
			}
			return true;
		}
		return false;
	}
	void resume(bool check=true)
	{
		if (schedule(check))
			f8_this_fiber::yield();
	}
	void resume_if()
	{
		if (joinable() && !is_detached())
			resume(false);
	}
	bool schedule_if()
	{
		return joinable() && !is_detached() ? schedule(false) : false;
	}
	template<typename Fn, typename... Args>
	requires std::invocable<Fn&&, Args...> && (!std::is_bind_expression_v<Fn>)
	constexpr void resume_with(Fn&& func, Args&&... args)
		{ resume_with(std::bind(std::forward<Fn>(func), std::forward<Args>(args)...)); }

	template<std::invocable Fn>
	void resume_with(Fn&& func)
	{
		_ctx->setup_continuation(std::forward<Fn>(func));
		resume();
	}

#if defined FIX8_FIBER_MULTITHREADING_
	void move(std::thread::id id)
	{
		get_all_cvars().queue_move(id, _ctx);
	}
#endif
	void swap(fiber& other) noexcept
	{
		if (_ctx != other._ctx)
			_ctx.swap(other._ctx);
	}
	static void sort() noexcept
	{
		sort_queue(GetVar(_sched));
	}

#if defined FIX8_FIBER_INSTRUMENTATION_
	static const cvars& const_get_vars() noexcept { return get_vars(); }
#if defined FIX8_FIBER_MULTITHREADING_
	static const all_cvars& const_get_all_cvars() noexcept { return get_all_cvars(); }
#endif
#endif
	bool joinable() const noexcept { return _ctx->joinable(); }
	bool is_main() const noexcept { return _ctx->is_main(); }
	bool is_detached() const noexcept { return _ctx->is_detached(); }
	bool is_suspended() const noexcept { return _ctx->is_suspended(); };
	bool is_joinonexit() const noexcept { return _ctx->is_joinonexit(); }
	bool is_dispatched() const noexcept { return _ctx->is_dispatched(); }
	bool is_transfering() const noexcept { return _ctx->is_transfering(); }
	bool is_moved() const noexcept { return _ctx->is_moved(); }
	explicit operator bool() const noexcept { return joinable(); }
	bool operator! () const noexcept { return !joinable(); }

	std::string_view name(std::string_view what) noexcept { return _ctx->name(what); }
	std::string_view name() const noexcept { return _ctx->name(); }
	int order(int ord=99) noexcept { return ord == 99 ? _ctx->_params.launch_order : _ctx->_params.launch_order = ord; }
	fiber_id get_id() const noexcept { return _ctx->get_id(); }
	fiber_id get_pid() const noexcept { return _ctx->get_pid(); }
	fiber_base_ptr get_ctx() noexcept { return _ctx; }

#if defined FIX8_FIBER_INSTRUMENTATION_
	fiber_id get_prev_id() const noexcept { return _ctx->get_prev_id(); }
	int get_ctxswtchs() const noexcept { return _ctx->_ctxswtchs; }
	friend std::ostream& operator<<(std::ostream& os, const fiber_base& what);
	friend std::ostream& operator<<(std::ostream& os, const fiber& what) { return os << *what._ctx; }
#endif
	friend f8_this_fiber;
	friend f8_fibers;
	friend fiber_base;
	friend class jfiber;
};

inline void swap(fiber& first, fiber& second) noexcept
{
	first.swap(second);
}

inline bool operator<(const fiber& left, const fiber& right) noexcept
{
	return left.get_id() < right.get_id();
}

//-----------------------------------------------------------------------------------------
class jfiber : public fiber
{
public:
	template<typename Fn, typename... Args>
	requires std::invocable<Fn&&, Args...> && (!std::is_bind_expression_v<Fn>)
	constexpr jfiber(Fn&& func, Args&&... args)
		: fiber({.join=true}, std::bind(std::forward<Fn>(func), std::forward<Args>(args)...)) {}

	template<typename Fn, typename... Args>
	requires std::invocable<Fn&&, Args...> && (!std::is_bind_expression_v<Fn>)
	constexpr jfiber(fiber_params&& params, Fn&& func, Args&&... args)
		: jfiber(std::move(params), std::bind(std::forward<Fn>(func), std::forward<Args>(args)...)) {}

	template<std::invocable Fn>
	constexpr jfiber(Fn&& func) : fiber({.join=true}, std::forward<Fn>(func)) {}

	template<std::invocable Fn>
	constexpr jfiber(fiber_params&& params, Fn&& func) : fiber(std::move(params), std::move(func)) { set_joinonexit(); }
};

//-----------------------------------------------------------------------------------------
template<std::invocable Fn, typename... Args>
class generator final : public std::ranges::view_interface<generator<Fn, Args ...>>
{
	using value = std::invoke_result_t<std::decay_t<Fn>, std::decay_t<Args>...>;
	class iterator;
	//using value = conditional_t<is_void_v<V>, remove_cvref_t<Ref>, V>;  // exposition only
	//using reference = conditional_t<is_void_v<V>, Ref&&, Ref>;

protected:
	fiber _fiber;

public:
	using promise_type = std::promise<value>;
	promise_type _promise;

	constexpr generator(Fn&& func, Args&&... args)
		: _fiber(std::forward<Fn>(func), std::forward<Args>(args)...) {}

	constexpr generator(fiber_params&& params, Fn&& func, Args&&... args)
		: _fiber(std::move(params), std::forward<Fn>(func), std::forward<Args>(args)...) {}

	constexpr generator(Fn&& func) : _fiber(std::forward<Fn>(func)) {}

	constexpr generator(fiber_params&& params, Fn&& func) : _fiber(std::move(params), std::move(func)) {}

	template <std::convertible_to<promise_type> From>
	void yield(From&& from) noexcept
	{
		_promise.set_value(std::forward<From>(from));
		f8_this_fiber::yield();
	}
/*
	class iterator
	{
		using value_type = value;
		 using difference_type = ptrdiff_t;

    iterator(iterator&& other) noexcept;
    iterator& operator=(iterator&& other) noexcept;

    reference operator*() const noexcept(is_nothrow_copy_constructible_v<reference>);
    iterator& operator++();
    void operator++(int);

    friend bool operator==(const iterator& i, default_sentinel_t);

  private:
    coroutine_handle<promise_type> coroutine_; // exposition only




		iterator::iterator(iterator&& other) noexcept;
		//Initializes coroutine_ with std::exchange(other.coroutine_, {});.

		iterator& operator=(iterator&& other) noexcept;
		//Equivalent to coroutine_ = std::exchange(other.coroutine_, {});.
		//Returns: *this.

		std::generator::iterator::operator*
		reference operator*() const
			 noexcept( std::is_nothrow_copy_constructible_v<reference> );
		(since C++23)
		Let reference be the std::generator's underlying type.
		Let for some generator object x its coroutine_ be in the stack *x.active_.
		Let x.active_->top() refer to a suspended coroutine with promise object p.
		Equivalent to return static_cast<reference>(*p.value_);.


		std::generator::iterator::operator++
		constexpr iterator& operator++();
		constexpr void operator++(int);
		operator==(iterator)
		friend bool operator==(const& i, std::default_sentinel_t);
	} */

	iterator begin();
	std::default_sentinel_t end() const noexcept;
};

//-----------------------------------------------------------------------------------------
template<typename Wrapper>
void fiber_base::trampoline(void *ptr) noexcept
{
	if (!f8_fibers::has_flag(global_fiber_flags::excepthandling))
		static_cast<Wrapper*>(ptr)->_func();
	else try
	{
		static_cast<Wrapper*>(ptr)->_func();
	}
	catch(...)
	{
		GetVar(_eptr) = std::current_exception();
	}
	GetVars();
	if (cur->joinable())
	{
		cur->_flags.set(fiber_base::finished);
		++fin;
	}
	if (!sch.empty())
		f8_this_fiber::yield();
	if (man) // pickup main
		coroswitch(cur.get(), man.get());
	fiber::fiber_exit(fiber::exit_path::tramp);
}

#if defined FIX8_FIBER_INSTRUMENTATION_
std::string fiber_base::get_flags_as_string() const noexcept
{
	char str[]{"mfspdnjtv"};
	if (GetVar(_gflags).test(static_cast<int>(global_fiber_flags::skipmain)))
		str[0] = 'M';
	for (int ii{}; ii < fiber_flags_count; ++ii)
		if (!_flags.test(ii))
			str[ii] = '_';
	return str;
}
#endif

//-----------------------------------------------------------------------------------------
// Activate per thread pending/suspended fibers at thread exit
fiber::cvars::~cvars() noexcept
{
	_term = true;
	if (!_sched.empty())
	{
		for (auto& pp : _sched)
			if (pp->is_suspended()) // unsuspend any suspended fiber
				pp->_flags.reset(fiber_base::suspended);
		f8_this_fiber::yield();
	}
#if defined FIX8_FIBER_MULTITHREADING_
	get_all_cvars().remove(std::this_thread::get_id()); // deregister this thread
#endif
}

//-----------------------------------------------------------------------------------------
#if defined FIX8_FIBER_INSTRUMENTATION_
std::ostream& operator<<(std::ostream& os, const fiber_base& what) // TODO replace with std::format
{
	os << (&what == ConstGetVar(_curr).get() ? '*' : ' ')
		<< ' ' << std::left << std::setw(4) << what.get_id()
		<< ' ' << std::left << std::setw(4) << what.get_pid()
		<< ' ' << std::left << std::setw(4) << what.get_prev_id()
		<< ' ' << std::right << std::setw(6) << what._ctxswtchs
		<< ' ' << std::right << std::setw(14) << what._stk
		<< ' ' << std::right << std::setw(14) << what._stk_alloc
		<< ' ' << std::right << std::setw(8) <<
			(what._stk_alloc ? (reinterpret_cast<unsigned long>(what._stk_alloc + what._stacksz
									 / sizeof(uintptr_t) - 1) - reinterpret_cast<unsigned long>(what._stk)) : 0)
		<< ' ' << std::right << std::setw(8) << what._stacksz
		<< ' ' << what.get_flags_as_string() << std::setw(4) << std::dec << what._params.launch_order
		<< ' ' << what._params.name;
	return os;
}
#endif

//-----------------------------------------------------------------------------------------
fiber_id f8_this_fiber::get_id() noexcept { return ConstGetVar(_curr)->get_id(); }
#if defined FIX8_FIBER_INSTRUMENTATION_
fiber_id f8_this_fiber::get_prev_id() noexcept { return ConstGetVar(_curr)->get_prev_id(); }
#endif
fiber_id f8_this_fiber::get_pid() noexcept { return ConstGetVar(_curr)->get_pid(); }

#if defined FIX8_FIBER_MULTITHREADING_
void f8_this_fiber::move(std::thread::id id)
{
	fiber::get_all_cvars().queue_move(id, GetVar(_curr));
}
#endif

void f8_this_fiber::yield() noexcept
{
	GetVars();
#if defined FIX8_FIBER_MULTITHREADING_
	fiber::get_all_cvars().move(); // process transfers to this thread
#endif
	while (!sch.empty())
	{
		auto front { sch.front() };
		sch.pop_front();
		if (front->joinable() && uni.contains(front))
		{
			if (front->is_suspended())
			{
				if (auto tse { front->_tp.time_since_epoch() };
					front->_tp.time_since_epoch() != decltype(tse)::zero() && front->_tp < std::chrono::steady_clock::now())
				{
					front->_flags.reset(fiber_base::suspended);
					front->_tp = decltype(front->_tp){};
				}
				else
				{
					sch.push_back(front);
					continue;
				}
			}
			else if (front->is_main())
			{
				if (trm)
					continue;
				else if (flg[static_cast<int>(global_fiber_flags::skipmain)] && !sch.empty())
				{
					sch.push_back(front); // main is not run, find next
					continue;
				}
			}
#if defined FIX8_FIBER_INSTRUMENTATION_
			auto snold { std::exchange(now, std::chrono::system_clock::now()) };
			cur->_extime += (cur->_exdelta = now - snold);
#endif
			front.swap(cur);
#if defined FIX8_FIBER_INSTRUMENTATION_
			cur->_prev_fiber = front->get_id();
			++cur->_ctxswtchs;
#endif
			if (cur->_flags[fiber_base::notstarted])
				cur->_flags.reset(fiber_base::notstarted);
			sch.push_back(front);
			if (front->_flags[fiber_base::transfer])
			{
				front->_flags.reset(fiber_base::transfer);
				front->_flags.set(fiber_base::moved);
			}
			fiber_base::coroswitch(front.get(), cur.get());
			break;
		}
		else if (!flg[static_cast<int>(global_fiber_flags::retain)])
			uni.erase(front);
	}
}
bool f8_this_fiber::schedule_main() noexcept
{
	GetVars();
	if (flg[static_cast<int>(global_fiber_flags::skipmain)])
		flg.reset(static_cast<int>(global_fiber_flags::skipmain));
	fiber fb{man};
	auto result { fb.schedule() };
	fb._ctx.reset();
	return result;
}

void f8_this_fiber::resume_main() noexcept
{
	GetVars();
	if (flg[static_cast<int>(global_fiber_flags::skipmain)])
		flg.reset(static_cast<int>(global_fiber_flags::skipmain));
	fiber fb{man};
	fb.resume();
	fb._ctx.reset();
}

template<typename Clock, typename Duration>
void f8_this_fiber::sleep_until(const std::chrono::time_point<Clock, Duration>& sltime)
{
	sleep_for(sltime - Clock::now());
}
template<typename Rep, typename Period>
void f8_this_fiber::sleep_for(const std::chrono::duration<Rep, Period>& retime)
{
	if (auto when { std::chrono::steady_clock::now() + retime }; when > std::chrono::steady_clock::now())
	{
		auto& cur { GetVar(_curr) };
		cur->_tp = when;
		cur->_flags.set(fiber_base::suspended);
		yield();
	}
}
std::string_view f8_this_fiber::name(std::string_view what) noexcept { return GetVar(_curr)->name(what); }
std::string_view f8_this_fiber::name() noexcept { return GetVar(_curr)->name(); }

//-----------------------------------------------------------------------------------------
int f8_fibers::size() noexcept { return ConstGetVar(_sched).size(); }
int f8_fibers::size_accurate() noexcept
{
	ConstGetVars();
	return std::count_if(sch.cbegin(), sch.cend(), [](const fiber_base_ptr& pp) { return pp->joinable(); });
}
int f8_fibers::size_finished() noexcept { return ConstGetVar(_finished); }
int f8_fibers::size_detached() noexcept
{
	ConstGetVars();
	return std::count_if(uni.cbegin(), uni.cend(), [](const fiber_base_ptr& pp) { return pp->is_detached(); });
}
std::exception_ptr f8_fibers::get_exception_ptr() noexcept { return ConstGetVar(_eptr); }
bool f8_fibers::has_fibers() noexcept { return size(); }
bool f8_fibers::has_finished() noexcept { return size_finished(); }
#if defined FIX8_FIBER_INSTRUMENTATION_
void f8_fibers::print(std::ostream& os) noexcept // TODO replace with std::format
{
#if defined FIX8_FIBER_MULTITHREADING_
	if (fiber::get_all_cvars().size() > 1)
		os << "Thread id " << std::this_thread::get_id() << '\n';
#endif
	os << "#      fid  pfid prev   ctxs      stack ptr    stack alloc    depth  stacksz     flags ord name\n";
	ConstGetVars();
	os << std::left << std::setw(5) << std::dec << 0 << *cur << std::endl;
	for (int pos{}; const auto& pp : sch) // scheduled
		if (pp->is_detached() ? !flg[static_cast<int>(global_fiber_flags::hidedetached)] : true)
			os << std::left << std::setw(5) << std::dec << ++pos << *pp << std::endl;
}
#endif
void f8_fibers::sort() noexcept { fiber::sort(); }
int f8_fibers::kill_all() noexcept
{
	int killed{};
	for (GetVars(); auto& pp : sch)
	{
		if (pp->joinable() && !pp->is_detached() && !pp->is_main())
		{
			pp->_flags.set(fiber_base::finished); // will not be scheduled again
			++fin;
			++killed;
		}
	}
	return killed;
}
#if defined FIX8_FIBER_MULTITHREADING_
void f8_fibers::move(std::thread::id id, fiber_base_ptr ptr)
{
	fiber::get_all_cvars().queue_move(id, ptr);
}
void f8_fibers::move(std::thread::id id, const fiber& fb)
{
	move(id, fb._ctx);
}
#endif

bool f8_fibers::has_flag(global_fiber_flags flag) noexcept { return ConstGetVar(_gflags).test(static_cast<int>(flag)); }
void f8_fibers::set_flag(global_fiber_flags flag) noexcept { GetVar(_gflags).set(static_cast<int>(flag)); }
void f8_fibers::reset_flag(global_fiber_flags flag) noexcept { GetVar(_gflags).reset(static_cast<int>(flag)); }
bool f8_fibers::terminating() noexcept { return ConstGetVar(_term); }
void f8_fibers::wait_all() noexcept
{
	while(has_fibers())
		f8_this_fiber::yield();
}
template<std::invocable Fn>
void f8_fibers::wait_all(Fn&& func) noexcept
{
	while(has_fibers() && !func())
		f8_this_fiber::yield();
}
void f8_fibers::wait_any() noexcept
{
	while(!has_finished())
		f8_this_fiber::yield();
}
template<std::invocable Fn>
void f8_fibers::wait_any(Fn&& func) noexcept
{
	while(!has_finished() && !func())
		f8_this_fiber::yield();
}

//-----------------------------------------------------------------------------------------
// custom async, uses fiber, modified boost::fiber::async
// uses std::invoke_result (std::result_of is deprecated)
// policy must be launch::dispatch
template<typename Fn, typename... Args>
requires std::invocable<Fn&&, Args...>
std::future<std::invoke_result_t<std::decay_t<Fn>, std::decay_t<Args>...>>
constexpr async(fiber_params&& params, Fn&& func, Args... args)
{
	using result_type = std::invoke_result_t<std::decay_t<Fn>, std::decay_t<Args>...>;
	std::packaged_task<result_type(std::decay_t<Args>...)> task { std::forward<Fn>(func) };
	std::future<result_type> fut { task.get_future() };
	const_cast<launch&>(params.policy) = launch::dispatch;
	fiber(std::forward<fiber_params>(params), std::move(task), std::forward<Args>(args)...).detach();
	return fut;
}

template<typename Fn, typename... Args>
requires std::invocable<Fn&&, Args...>
std::future<std::invoke_result_t<std::decay_t<Fn>, std::decay_t<Args>...>>
constexpr async(Fn&& func, Args... args) { return async({}, std::forward<Fn>(func), std::forward<Args>(args)...); }

//-----------------------------------------------------------------------------------------
// helper templates
template<std::invocable... Fns>
constexpr void launch_all(Fns&& ...funcs)
{
	(fiber(std::forward<Fns>(funcs)).detach(), ...);
}

template<typename Ps, std::invocable Fn, typename... Fns>
constexpr void launch_all_with_params(Ps&& params, Fn&& func, Fns&& ...funcs)
{
   fiber(std::forward<Ps>(params), std::forward<Fn>(func)).detach();
   if constexpr(sizeof...(Fns))
      launch_all_with_params(std::forward<Fns>(funcs)...);
}

template <typename C>
concept container_emplace_back = requires(C& c)
{
	c.emplace_back();
	c.begin();
};

template<container_emplace_back C, std::invocable... Fns>
constexpr void launch_all_n(C& c, Fns&& ...funcs)
{
	(c.emplace_back(std::forward<Fns>(funcs)), ...);
   if constexpr(sizeof...(Fns))
		c.begin()->resume();
}

template<container_emplace_back C, typename Ps, std::invocable Fn, typename... Fns>
constexpr void launch_all_with_params_n(C& c, Ps&& params, Fn&& func, Fns&& ...funcs)
{
	c.emplace_back(std::forward<Ps>(params), std::forward<Fn>(func));
   if constexpr(sizeof...(Fns))
      launch_all_with_params_n(c, std::forward<Fns>(funcs)...);
	else
		c.begin()->resume();
}

template<typename T=fiber, typename... Args>
requires std::derived_from<T, fiber>
constexpr fiber_ptr make_fiber(Args&&... args)
{
	return fiber_ptr(new T(std::forward<Args>(args)...));
}

template<typename T=fiber, typename... Args>
requires std::derived_from<T, fiber>
constexpr fiber_ptr make_fiber(fiber_params&& params, Args&&... args)
{
	return fiber_ptr(new T(std::forward<fiber_params>(params), std::forward<Args>(args)...));
}

//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
namespace this_fiber
{
	inline fiber_id get_id() noexcept { return f8_this_fiber::get_id(); }
#if defined FIX8_FIBER_INSTRUMENTATION_
	inline fiber_id get_prev_id() noexcept { return f8_this_fiber::get_prev_id(); }
#endif
	inline fiber_id get_pid() noexcept { return f8_this_fiber::get_pid(); }
#if defined FIX8_FIBER_MULTITHREADING_
	inline void move(std::thread::id id) { f8_this_fiber::move(id); }
#endif
	inline void yield() noexcept { return f8_this_fiber::yield(); }
	inline void resume_main() noexcept { return f8_this_fiber::resume_main(); }
	inline bool schedule_main() noexcept { return f8_this_fiber::schedule_main(); }
	inline std::string_view name(std::string_view what) noexcept { return f8_this_fiber::name(what); }
	inline std::string_view name() noexcept { return f8_this_fiber::name(); }

	template<typename Clock, typename Duration>
	inline void sleep_until(const std::chrono::time_point<Clock, Duration>& sltime)
		{ return f8_this_fiber::sleep_until(sltime); }

	template<typename Rep, typename Period>
	inline void sleep_for(const std::chrono::duration<Rep, Period>& retime)
		{ return f8_this_fiber::sleep_for(retime); }
}

namespace fibers
{
	inline int size() noexcept { return f8_fibers::size(); }
	inline int size_accurate() noexcept { return f8_fibers::size_accurate(); }
	inline int size_finished() noexcept { return f8_fibers::size_finished(); }
	inline int size_detached() noexcept { return f8_fibers::size_detached(); }
	inline bool has_fibers() noexcept { return f8_fibers::size() != 0; }
	inline bool has_finished() noexcept { return f8_fibers::has_finished(); }
	inline bool has_flag(global_fiber_flags flag) noexcept { return f8_fibers::has_flag(flag); }
	inline void set_flag(global_fiber_flags flag) noexcept { f8_fibers::set_flag(flag); }
	inline void reset_flag(global_fiber_flags flag) noexcept { f8_fibers::reset_flag(flag); }
#if defined FIX8_FIBER_INSTRUMENTATION_
	inline void print(std::ostream& os=std::cout) noexcept { f8_fibers::print(os); }
	inline const fiber::cvars& const_get_vars() noexcept { return fiber::const_get_vars(); }
	inline std::exception_ptr get_exception_ptr() noexcept { return f8_fibers::get_exception_ptr(); }
#if defined FIX8_FIBER_MULTITHREADING_
	inline const fiber::all_cvars& const_get_all_cvars() noexcept { return fiber::const_get_all_cvars(); }
	inline void move(std::thread::id id, fiber_base_ptr ptr) noexcept { f8_fibers::move(id, ptr); }
	inline void move(std::thread::id id, const fiber& fb) noexcept { f8_fibers::move(id, fb); }
#endif
#endif
	inline void sort() noexcept { f8_fibers::sort(); };
	inline int kill_all() noexcept { return f8_fibers::kill_all(); }
	inline bool terminating() noexcept { return f8_fibers::terminating(); }
	inline void wait_all() noexcept { f8_fibers::wait_all(); }
	template<std::invocable Fn>
	void wait_all(Fn func) noexcept { f8_fibers::wait_all(std::move(func)); }
	inline void wait_any() noexcept { f8_fibers::wait_any(); }
	template<std::invocable Fn>
	void wait_any(Fn func) noexcept { f8_fibers::wait_any(std::move(func)); }
};

} // namespace FIX8

// allowed specialisation of std::hash for fiber_id
template<>
struct std::hash<FIX8::fiber_id>
{
	std::size_t operator()(const FIX8::fiber_id& id) const noexcept { return reinterpret_cast<std::size_t>(id._ptr); }
};

#endif // FIX8_FIBER_HPP_
